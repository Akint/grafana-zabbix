{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"lodash\"","webpack:///external \"moment\"","webpack:///./datasource-zabbix/utils.js","webpack:///external \"app/plugins/sdk\"","webpack:///external \"angular\"","webpack:///external \"jquery\"","webpack:///./datasource-zabbix/constants.js","webpack:///external \"app/core/utils/datemath\"","webpack:///./datasource-zabbix/migrations.ts","webpack:///./datasource-zabbix/metricFunctions.js","webpack:///./datasource-zabbix/zabbix/connectors/dbConnector.js","webpack:///./datasource-zabbix/responseHandler.js","webpack:///./datasource-zabbix/zabbix/connectors/zabbix_api/zabbixAPICore.js","webpack:///./datasource-zabbix/module.js","webpack:///./datasource-zabbix/datasource.js","webpack:///external \"app/core/config\"","webpack:///./datasource-zabbix/dataProcessor.js","webpack:///./datasource-zabbix/timeseries.js","webpack:///external \"app/core/table_model\"","webpack:///./datasource-zabbix/zabbix/zabbix.js","webpack:///./datasource-zabbix/zabbix/proxy/cachingProxy.js","webpack:///./datasource-zabbix/zabbix/connectors/zabbix_api/zabbixAPIConnector.js","webpack:///./datasource-zabbix/zabbix/connectors/sql/sqlConnector.js","webpack:///./datasource-zabbix/zabbix/connectors/sql/mysql.js","webpack:///./datasource-zabbix/zabbix/connectors/sql/postgres.js","webpack:///./datasource-zabbix/zabbix/connectors/influxdb/influxdbConnector.js","webpack:///./datasource-zabbix/query.controller.js","webpack:///./datasource-zabbix/config.controller.js","webpack:///./datasource-zabbix/zabbixAlerting.service.js","webpack:///./datasource-zabbix/add-metric-function.directive.js","webpack:///./datasource-zabbix/metric-function-editor.directive.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_EXTERNAL_MODULE__1__","__WEBPACK_EXTERNAL_MODULE__3__","expandItemName","expandItems","items","_","forEach","item","key_","containsMacro","itemName","MACRO_PATTERN","test","replaceMacro","macros","item_macros","match","macro","host_macros","filter","hostid","macro_def","find","macro_value","macro_regex","RegExp","replace","escapeMacro","splitTemplateQuery","query","split","isContainsBraces","result","map","part","trim","isRegex","str","regexPattern","isTemplateVariable","templateVariables","variables","variable","includes","buildRegex","matches","pattern","flags","undefined","escapeRegex","parseInterval","interval","momentInterval","exec","moment","duration","Number","valueOf","parseTimeShiftInterval","formatAcknowledges","acknowledges","length","formatted_acknowledges","each","ack","timestamp","unix","clock","format","alias","surname","message","concat","convertToZabbixAPIUrl","url","callOnce","func","promiseKeeper","Promise","resolve","apply","this","arguments","then","sequence","funcsArray","isValidVersion","version","versionPattern","parseVersion","major","minor","patch","meta","compactQuery","getArrayDepth","a","level","elem","isArray","key_params","paramStr","params","quoted","in_array","param","symbol","push","splitKeyParams","substring","indexOf","lastIndexOf","contains","__WEBPACK_EXTERNAL_MODULE__6__","__WEBPACK_EXTERNAL_MODULE__10__","__WEBPACK_EXTERNAL_MODULE__11__","DATAPOINT_VALUE","DATAPOINT_TS","MODE_METRICS","MODE_ITSERVICE","MODE_TEXT","MODE_ITEMID","MODE_TRIGGERS","SEV_NOT_CLASSIFIED","SEV_INFORMATION","SEV_WARNING","SEV_AVERAGE","SEV_HIGH","SEV_DISASTER","SHOW_ALL_TRIGGERS","SHOW_ALL_EVENTS","SHOW_OK_EVENTS","ZBX_ACK_ACTION_NONE","ZBX_ACK_ACTION_ACK","ZBX_ACK_ACTION_ADD_MESSAGE","TRIGGER_SEVERITY","val","text","__WEBPACK_EXTERNAL_MODULE__17__","__webpack_exports__","isGrafana2target","migrateFrom2To3version","migrate","DS_CONFIG_SCHEMA","migrateDSConfig","lodash__WEBPACK_IMPORTED_MODULE_0__","lodash__WEBPACK_IMPORTED_MODULE_0___default","target","hostFilter","itemFilter","downsampleFunction","host","group","convertToRegex","application","resultFormat","Array","fixTargetGroup","functions","_i","_a","f","def","migratePercentileAgg","jsonData","dbConnection","isEmpty","schema","shouldMigrateDSConfig","oldVersion","dbConnectionOptions","dbConnectionEnable","enable","dbConnectionDatasourceId","datasourceId","createFuncInstance","funcDef","isString","index","FuncInstance","getFuncDef","getCategories","categories","Transform","Aggregate","Filter","Trends","Time","Alias","Special","addFuncDef","defaultParams","category","shortName","type","options","funcList","catName","sortBy","_classCallCheck","slice","updateText","metricFunctions","bindedFunc","partial","metricExp","parameters","paramType","$","isNumeric","unshift","join","strValue","optional","_hasMultipleParamsInString","partVal","idx","updateParam","splice","DEFAULT_QUERY_LIMIT","HISTORY_TO_TABLE_MAP","0","1","2","3","4","TREND_TO_TABLE_MAP","consolidateByFunc","avg","min","max","sum","count","consolidateByTrendColumns","DBConnector","datasourceSrv","datasourceName","datasourceTypeId","datasourceTypeName","_this","loadDatasource","ds","id","ZabbixNotImplemented","history","time_series","addHostName","hosts","uniqBy","flatten","grafanaSeries","compact","series","itemid","keys","datapoints","cloneDeep","points","convertGrafanaTSResponse","dsId","dsName","getAll","reject","methodName","code","defaults","convertHistory","convertPointCallback","grouped_history","groupBy","hist","convertText","point","textFilter","extractText","useCaptureGroups","Math","round","extractedValue","convertHistoryPoint","convertTrendPoint","valueType","value_min","value_max","value_avg","value_sum","value_count","handleHistory","handleTrends","handleText","handleHistoryAsTable","table","TableModel","addColumn","itemHistory","lastPoint","last","lastValue","skipEmptyValues","first","rows","handleSLAResponse","itservice","slaProperty","slaObject","targetSLA","serviceid","sla","targetStatus","parseInt","status","to","from","handleTriggersResponse","triggers","groups","timeRange","isNumber","stats","uniq","flattenDeep","trigger","5","priority","getTriggerStats","groupNames","orderBy","severity","severity_stats","row","toPairs","_lodash2","default","_toConsumableArray","sortTimeseries","timeseries","ZabbixAPICore","backendSrv","$inject","api_url","auth","requestData","jsonrpc","method","ZabbixAPIError","data","headers","requestOptions","withCredentials","Authorization","basicAuth","datasourceRequest","response","error","username","password","user","request","AnnotationsQueryCtrl","QueryOptionsCtrl","QueryCtrl","ConfigCtrl","Datasource","_sdk","_datasource","_query","_config","ZabbixQueryOptionsController","templateUrl","ZabbixAnnotationsQueryController","ZabbixDSConfigController","dark","loadPluginCss","light","ZabbixQueryController","zabbixTemplateFormat","replaceTemplateVars","templateSrv","_interopRequireDefault","_config2","dateMath","_interopRequireWildcard","utils","migrations","_dataProcessor2","_responseHandler2","_zabbix","_zabbixAPICore","obj","newObj","DEFAULT_ZABBIX_VERSION","ZabbixDatasource","instanceSettings","instance","Constructor","TypeError","zabbixAlertingSrv","enableDebugLog","buildInfo","env","trends","trendsFrom","trendsRange","ttl","cacheTTL","alertingEnabled","alerting","addThresholds","alertingMinSeverity","disableReadOnlyUsersAck","zabbixVersion","enableDirectDBConnection","dbConnectionDatasourceName","dbConnectionRetentionPolicy","zabbixOptions","zabbix","Zabbix","_createClass","promises","targets","hide","timeFrom","range","timeTo","parse","removeZabbixThreshold","panelId","alert","thresholds","threshold","setPanelThreshold","replaceTargetVariables","ceil","timeFunctions","bindFunctionDefs","queryNumericData","_utils$sequence","_utils$sequence2","queryTextData","useTrends","isUseTrends","itemids","queryItemIdData","all","queryITServiceData","_this3","getTrendValueType","consolidateBy","getConsolidateBy","getTrends","getHistoryTS","applyDataProcessingFunctions","downsampleSeries","filterFunctions","timeseries_data","trendValueFunc","trendFunctions","transformFunctions","aggregationFunctions","aliasFunctions","aggFuncNames","dp","findLast","applyTimeShiftFunction","responseHandler","getVersion","parts","template","zipObject","app","_this8","getHosts","getItems","getGroups","metrics","formatMetric","triggerName","annotation","_this9","description","showOkEvents","hideHostsInMaintenance","indexedTriggers","minseverity","getEvents","objectids","triggersOptions","keyBy","hideAcknowledged","events","tags","title","event","time","objectid","downsample","ts","groupBy_exported","_timeseries2","sumSeries","rate","scale","delta","offset","AVERAGE","MIN","MAX","MEDIAN","PERCENTILE","order","orderByFunc","sortByIteratee","orderByCallback","sortedTimeseries","values","aggregateWrapper","groupByCallback","sortedPoints","sortByTime","flattenedPoints","groupFunc","simpleMovingAverage","factor","scale_perf","expMovingAverage","movingAverage","exponentialMovingAverage","transformNull","aggregateBy","percentile","flattenDatapoints","aggregateFunc","median","SUM","COUNT","removeAboveValue","removeBelowValue","top","bottom","sortSeries","limit","timeShift","setAlias","direction","toLowerCase","setAliasByRegex","shift","replaceAlias","extractPattern","regexp","newAlias","unShiftTimeSeries","getPointTimeFrame","ms_interval","left","right","findNearestLeft","findNearestRight","linearInterpolation","pointIndex","groupBy_perf","points_sum","frame","points_num","downsampledSeries","timeWindow","frames","grouped","mapValues","point_frame_ts","frame_values","frame_value","frame_ts","POINT_TIMESTAMP","grouped_series","POINT_VALUE","new_timestamps","interpolated_timeseries","timestamps","new_point","append","prepend","new_points","difference","new_series","new_timeseries","interpolateSeries","j","deltaValue","newSeries","point_prev","valueDelta","timeDelta","w_avg","w_count","sma","w_sum","ema_cur","ema_prev","ema","values_non_null","getNonNullValues","sorted","floor","_dbConnector","_zabbixAPIConnector","REQUESTS_TO_PROXYFY","arr","arr2","REQUESTS_TO_BIND","cachingProxy","zabbixAPI","ZabbixAPIConnector","proxyfyRequests","bindRequests","connectorOptions","initDBConnector","proxyfyWithCache","dbConnector","getHistoryDB","getHistory","getTrendsDB","_this2","retentionPolicy","SQLConnector","_sqlConnector","_iteratorNormalCompletion","_iteratorError","_step","_iterator","iterator","next","done","_iteratorNormalCompletion2","_step2","_iterator2","REQUESTS_TO_CACHE","_iteratorNormalCompletion3","_iteratorError3","_step3","_iterator3","dbConnectorStatus","login","testDataSource","catch","dsType","filters","getApps","results","appFilterEmpty","_results","_slicedToArray","apps","groupFilter","getAllGroups","_this4","groupids","getAllHosts","_this5","hostids","appFilter","_this6","filterByQuery","_this7","appids","itemtype","showDisabledItems","hostIds","getHostIds","itServiceFilter","getITService","proxyFilter","filteredGroups","_results2","filteredApps","filteredHosts","proxy_ids","filtered","proxy","proxyid","proxy_hostid","proxies","getProxies","findByFilter","_timeRange","_timeRange2","_timeRange3","itservices","isOldVersion","itServices","itServiceIds","slaResponse","filterPattern","list","zbx_obj","filterByRegex","findByName","finded","filterByName","CachingProxy","cacheOptions","cache","cacheRequest","funcName","funcScope","self","cacheEnabled","hash","cacheObject","_isExpired","Date","now","getRequestHash","object_age","argsJson","getHash","JSON","stringify","args","String","len","chr","charCodeAt","_arr","_n","_d","_e","_s","err","sliceIterator","defineProperties","props","descriptor","configurable","writable","protoProps","staticProps","_constants","maxLoginAttempts","zabbixAPICore","getTrend","getTrend_ZBXNEXT1193","isNotAuthorized","loginErrorCount","loginOnce","loginPromise","action","eventid","eventids","real_hosts","output","sortfield","selectHosts","value_type","webitems","timeTill","grouped_items","sortorder","time_from","trend","time_till","serviceids","intervals","applicationids","showTriggers","maintenance","expandDescription","expandData","expandComment","monitored","skipDependent","selectGroups","selectItems","selectLastEvent","selectTags","lastChangeTill","lastChangeSince","showEvents","select_acknowledges","preservekeys","selectUsers","minSeverity","acknowledged","min_severity","filterTriggersByAcknowledge","lastEvent","_utils","_mysql2","supportedDatabases","_dbConnector2","postgres","_DBConnector","ReferenceError","sqlDialect","_get","getPrototypeOf","loadSQLDialect","subClass","superClass","constructor","setPrototypeOf","__proto__","_inherits","mysql","testQuery","intervalSec","intervalMs","aggFunction","historyQuery","valueColumn","trendsQuery","refId","rawSql","maxDataPoints","queries","TEST_QUERY","time_expression","ITEMID_FORMAT","InfluxDBConnector","_possibleConstructorReturn","influxDS","buildHistoryQuery","invokeInfluxDBQuery","handleInfluxHistoryResponse","seriesList","influxSeriesList","y","influxSeries","timeSeries","measurement","aggregation","buildWhereClause","_QueryCtrl","$scope","$injector","editorModes","datasource","editorMode","ITSERVICE","ITEMID","TRIGGERS","slaPropertyList","ackFilters","resultFormats","getGroupNames","getItemNames","getMetricNames","getITServices","getVariables","getTemplateVariables","$rootScope","$on","onVariableChange","init","metric","queryOptionsText","scopeDefaults","targetDefaults","initFilters","renderQueryOptionsText","suggestGroups","suggestHosts","suggestApps","suggestItems","metricList","addAllValue","hostList","appList","getAllApps","getAllItems","newTarget","targetChanged","isEqual","oldTarget","isContainsVariables","field","some","refresh","newFunc","moveAliasFuncLast","added","aliasFunc","showQueryOptions","onTargetBlur","optionsMap","forOwn","SUPPORTED_SQL_DS","defaultConfig","current","zabbixVersions","autoDetectZabbixVersion","dbDataSources","loadCurrentDBDatasource","datasources","currentDs","ZabbixAlertingService","_angular2","dashboardSrv","dash","fullscreen","panelContainers","alertState","isFullScreen","clientWidth","panelIndex","findIndex","panelModels","panel","alertClass","_jquery2","addClass","removeClass","getPanelModel","thresholdOptions","colorMode","fill","lineColor","containsThreshold","op","source","angular","$compile","inputTemplate","directive","buttonTemplate","$input","$button","reduce","getAllFunctionNames","click","submenu","createFunctionDropDownMenu","typeahead","allFunctions","minLength","updater","$apply","addFunction","keyup","toggleClass","focus","setTimeout","funcSpanTemplate","paramTemplate","restrict","link","scheduledRelink","paramCountAtLink","clickFuncParam","$link","paramIndex","select","width","scheduledRelinkIfNeeded","highlightVariablesAsHtml","newValue","show","ctrl","inputKeyPress","e","inputKeyDown","which","inputBlur","addTypeahead","targetDiv","$funcControls","closest","hasClass","addElementsAndCompile","$funcLink","appendTo","$paramLink","paramValue","keypress","toString","lookup","toggleFuncControls","ifJustAddedFocusFistParam","registerFuncControlsToggle","registerFuncControlsActions","$target","removeFunction","docSite","DOCS_FUNC_REF_URL"],"mappings":"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","file":"datasource-zabbix/module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 35);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","module.exports = __WEBPACK_EXTERNAL_MODULE__3__;","import _ from 'lodash';\nimport moment from 'moment';\n\n/**\n * Expand Zabbix item name\n *\n * @param  {string} name item name, ie \"CPU $2 time\"\n * @param  {string} key  item key, ie system.cpu.util[,system,avg1]\n * @return {string}      expanded name, ie \"CPU system time\"\n */\nexport function expandItemName(name, key) {\n\n  // extract params from key:\n  // \"system.cpu.util[,system,avg1]\" --> [\"\", \"system\", \"avg1\"]\n  let key_params_str = key.substring(key.indexOf('[') + 1, key.lastIndexOf(']'));\n  let key_params = splitKeyParams(key_params_str);\n\n  // replace item parameters\n  for (let i = key_params.length; i >= 1; i--) {\n    name = name.replace('$' + i, key_params[i - 1]);\n  }\n  return name;\n}\n\nexport function expandItems(items) {\n  _.forEach(items, item => {\n    item.item = item.name;\n    item.name = expandItemName(item.item, item.key_);\n    return item;\n  });\n  return items;\n}\n\nfunction splitKeyParams(paramStr) {\n  let params = [];\n  let quoted = false;\n  let in_array = false;\n  let split_symbol = ',';\n  let param = '';\n\n  _.forEach(paramStr, symbol => {\n    if (symbol === '\"' && in_array) {\n      param += symbol;\n    } else if (symbol === '\"' && quoted) {\n      quoted = false;\n    } else if (symbol === '\"' && !quoted) {\n      quoted = true;\n    } else if (symbol === '[' && !quoted) {\n      in_array  = true;\n    } else if (symbol === ']' && !quoted) {\n      in_array = false;\n    } else if (symbol === split_symbol && !quoted && !in_array) {\n      params.push(param);\n      param = '';\n    } else {\n      param += symbol;\n    }\n  });\n\n  params.push(param);\n  return params;\n}\n\nconst MACRO_PATTERN = /{\\$[A-Z0-9_\\.]+}/g;\n\nexport function containsMacro(itemName) {\n  return MACRO_PATTERN.test(itemName);\n}\n\nexport function replaceMacro(item, macros) {\n  let itemName = item.name;\n  let item_macros = itemName.match(MACRO_PATTERN);\n  _.forEach(item_macros, macro => {\n    let host_macros = _.filter(macros, m => {\n      if (m.hostid) {\n        return m.hostid === item.hostid;\n      } else {\n        // Add global macros\n        return true;\n      }\n    });\n\n    let macro_def = _.find(host_macros, { macro: macro });\n    if (macro_def && macro_def.value) {\n      let macro_value = macro_def.value;\n      let macro_regex = new RegExp(escapeMacro(macro));\n      itemName = itemName.replace(macro_regex, macro_value);\n    }\n  });\n\n  return itemName;\n}\n\nfunction escapeMacro(macro) {\n  macro = macro.replace(/\\$/, '\\\\\\$');\n  return macro;\n}\n\n/**\n * Split template query to parts of zabbix entities\n * group.host.app.item -> [group, host, app, item]\n * {group}{host.com} -> [group, host.com]\n */\nexport function splitTemplateQuery(query) {\n  let splitPattern = /\\{[^\\{\\}]*\\}|\\{\\/.*\\/\\}/g;\n  let split;\n\n  if (isContainsBraces(query)) {\n    let result = query.match(splitPattern);\n    split = _.map(result, part => {\n      return _.trim(part, '{}');\n    });\n  } else {\n    split = query.split('.');\n  }\n\n  return split;\n}\n\nfunction isContainsBraces(query) {\n  let bracesPattern = /^\\{.+\\}$/;\n  return bracesPattern.test(query);\n}\n\n// Pattern for testing regex\nexport const regexPattern = /^\\/(.*)\\/([gmi]*)$/m;\n\nexport function isRegex(str) {\n  return regexPattern.test(str);\n}\n\nexport function isTemplateVariable(str, templateVariables) {\n  var variablePattern = /^\\$\\w+/;\n  if (variablePattern.test(str)) {\n    var variables = _.map(templateVariables, variable => {\n      return '$' + variable.name;\n    });\n    return _.includes(variables, str);\n  } else {\n    return false;\n  }\n}\n\nexport function buildRegex(str) {\n  var matches = str.match(regexPattern);\n  var pattern = matches[1];\n  var flags = matches[2] !== \"\" ? matches[2] : undefined;\n  return new RegExp(pattern, flags);\n}\n\n// Need for template variables replace\n// From Grafana's templateSrv.js\nexport function escapeRegex(value) {\n  return value.replace(/[\\\\^$*+?.()|[\\]{}\\/]/g, '\\\\$&');\n}\n\nexport function parseInterval(interval) {\n  var intervalPattern = /(^[\\d]+)(y|M|w|d|h|m|s)/g;\n  var momentInterval = intervalPattern.exec(interval);\n  return moment.duration(Number(momentInterval[1]), momentInterval[2]).valueOf();\n}\n\nexport function parseTimeShiftInterval(interval) {\n  let intervalPattern = /^([\\+\\-]*)([\\d]+)(y|M|w|d|h|m|s)/g;\n  let momentInterval = intervalPattern.exec(interval);\n  let duration = 0;\n\n  if (momentInterval[1] === '+') {\n    duration = 0 - moment.duration(Number(momentInterval[2]), momentInterval[3]).valueOf();\n  } else {\n    duration = moment.duration(Number(momentInterval[2]), momentInterval[3]).valueOf();\n  }\n\n  return duration;\n}\n\n/**\n * Format acknowledges.\n *\n * @param  {array} acknowledges array of Zabbix acknowledge objects\n * @return {string} HTML-formatted table\n */\nexport function formatAcknowledges(acknowledges) {\n  if (acknowledges.length) {\n    var formatted_acknowledges = '<br><br>Acknowledges:<br><table><tr><td><b>Time</b></td>'\n      + '<td><b>User</b></td><td><b>Comments</b></td></tr>';\n    _.each(_.map(acknowledges, function (ack) {\n      var timestamp = moment.unix(ack.clock);\n      return '<tr><td><i>' + timestamp.format(\"DD MMM YYYY HH:mm:ss\") + '</i></td><td>' + ack.alias\n        + ' (' + ack.name + ' ' + ack.surname + ')' + '</td><td>' + ack.message + '</td></tr>';\n    }), function (ack) {\n      formatted_acknowledges = formatted_acknowledges.concat(ack);\n    });\n    formatted_acknowledges = formatted_acknowledges.concat('</table>');\n    return formatted_acknowledges;\n  } else {\n    return '';\n  }\n}\n\nexport function convertToZabbixAPIUrl(url) {\n  var zabbixAPIUrlPattern = /.*api_jsonrpc.php$/;\n  var trimSlashPattern = /(.*?)[\\/]*$/;\n  if (url.match(zabbixAPIUrlPattern)) {\n    return url;\n  } else {\n    return url.replace(trimSlashPattern, \"$1\");\n  }\n}\n\n/**\n * Wrap function to prevent multiple calls\n * when waiting for result.\n */\nexport function callOnce(func, promiseKeeper) {\n  return function() {\n    if (!promiseKeeper) {\n      promiseKeeper = Promise.resolve(\n        func.apply(this, arguments)\n        .then(result => {\n          promiseKeeper = null;\n          return result;\n        })\n      );\n    }\n    return promiseKeeper;\n  };\n}\n\n/**\n * Apply function one by one: `sequence([a(), b(), c()]) = c(b(a()))`\n * @param {*} funcsArray functions to apply\n */\nexport function sequence(funcsArray) {\n  return function(result) {\n    for (var i = 0; i < funcsArray.length; i++) {\n      result = funcsArray[i].call(this, result);\n    }\n    return result;\n  };\n}\n\nconst versionPattern = /^(\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))?(?:-([0-9A-Za-z\\.]+))?/;\n\nexport function isValidVersion(version) {\n  return versionPattern.exec(version);\n}\n\nexport function parseVersion(version) {\n  const match = versionPattern.exec(version);\n  if (!match) {\n    return null;\n  }\n  const major = Number(match[1]);\n  const minor = Number(match[2] || 0);\n  const patch = Number(match[3] || 0);\n  const meta = match[4];\n  return { major, minor, patch, meta };\n}\n\n/**\n * Replaces any space-like symbols (tabs, new lines, spaces) by single whitespace.\n */\nexport function compactQuery(query) {\n  return query.replace(/\\s+/g, ' ').trim();\n}\n\nexport function getArrayDepth(a, level = 0) {\n  if (a.length === 0) {\n    return 1;\n  }\n  const elem = a[0];\n  if (_.isArray(elem)) {\n    return getArrayDepth(elem, level + 1);\n  }\n  return level + 1;\n}\n\n// Fix for backward compatibility with lodash 2.4\nif (!_.includes) {\n  _.includes = _.contains;\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__6__;","module.exports = __WEBPACK_EXTERNAL_MODULE__10__;","module.exports = __WEBPACK_EXTERNAL_MODULE__11__;","// Data point\nexport const DATAPOINT_VALUE = 0;\nexport const DATAPOINT_TS = 1;\n\n// Editor modes\nexport const MODE_METRICS = 0;\nexport const MODE_ITSERVICE = 1;\nexport const MODE_TEXT = 2;\nexport const MODE_ITEMID = 3;\nexport const MODE_TRIGGERS = 4;\n\n// Triggers severity\nexport const SEV_NOT_CLASSIFIED = 0;\nexport const SEV_INFORMATION = 1;\nexport const SEV_WARNING = 2;\nexport const SEV_AVERAGE = 3;\nexport const SEV_HIGH = 4;\nexport const SEV_DISASTER = 5;\n\nexport const SHOW_ALL_TRIGGERS = [0, 1];\nexport const SHOW_ALL_EVENTS = [0, 1];\nexport const SHOW_OK_EVENTS = 1;\n\n// Acknowledge\nexport const ZBX_ACK_ACTION_NONE = 0;\nexport const ZBX_ACK_ACTION_ACK = 2;\nexport const ZBX_ACK_ACTION_ADD_MESSAGE = 4;\n\nexport const TRIGGER_SEVERITY = [\n  {val: 0, text: 'Not classified'},\n  {val: 1, text: 'Information'},\n  {val: 2, text: 'Warning'},\n  {val: 3, text: 'Average'},\n  {val: 4, text: 'High'},\n  {val: 5, text: 'Disaster'}\n];\n","module.exports = __WEBPACK_EXTERNAL_MODULE__17__;","import _ from 'lodash';\n\n/**\n * Query format migration.\n * This module can detect query format version and make migration.\n */\n\nexport function isGrafana2target(target) {\n  if (!target.mode || target.mode === 0 || target.mode === 2) {\n    if ((target.hostFilter || target.itemFilter || target.downsampleFunction ||\n        (target.host && target.host.host)) &&\n        (target.item.filter === undefined && target.host.filter === undefined)) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n\nexport function migrateFrom2To3version(target) {\n  target.group.filter = target.group.name === \"*\" ? \"/.*/\" : target.group.name;\n  target.host.filter = target.host.name === \"*\" ? convertToRegex(target.hostFilter) : target.host.name;\n  target.application.filter = target.application.name === \"*\" ? \"\" : target.application.name;\n  target.item.filter = target.item.name === \"All\" ? convertToRegex(target.itemFilter) : target.item.name;\n  return target;\n}\n\nexport function migrate(target) {\n  target.resultFormat = target.resultFormat || 'time_series';\n  target = fixTargetGroup(target);\n  if (isGrafana2target(target)) {\n    return migrateFrom2To3version(target);\n  }\n  migratePercentileAgg(target);\n  return target;\n}\n\nfunction fixTargetGroup(target) {\n  if (target.group && Array.isArray(target.group)) {\n    target.group = { 'filter': \"\" };\n  }\n  return target;\n}\n\nfunction convertToRegex(str) {\n  if (str) {\n    return '/' + str + '/';\n  } else {\n    return '/.*/';\n  }\n}\n\nfunction migratePercentileAgg(target) {\n  if (target.functions) {\n    for (const f of target.functions) {\n      if (f.def && f.def.name === 'percentil') {\n        f.def.name = 'percentile';\n      }\n    }\n  }\n}\n\nexport const DS_CONFIG_SCHEMA = 2;\nexport function migrateDSConfig(jsonData) {\n  if (!jsonData) {\n    jsonData = {};\n  }\n\n  if (!shouldMigrateDSConfig(jsonData)) {\n    return jsonData;\n  }\n\n  const oldVersion = jsonData.schema || 1;\n  jsonData.schema = DS_CONFIG_SCHEMA;\n\n  if (oldVersion < 2) {\n    const dbConnectionOptions = jsonData.dbConnection || {};\n    jsonData.dbConnectionEnable = dbConnectionOptions.enable || false;\n    jsonData.dbConnectionDatasourceId = dbConnectionOptions.datasourceId || null;\n    delete jsonData.dbConnection;\n  }\n\n  return jsonData;\n}\n\nfunction shouldMigrateDSConfig(jsonData): boolean {\n  if (jsonData.dbConnection && !_.isEmpty(jsonData.dbConnection)) {\n    return true;\n  }\n  if (jsonData.schema && jsonData.schema !== DS_CONFIG_SCHEMA) {\n    return true;\n  }\n  return false;\n}\n","import _ from 'lodash';\nimport $ from 'jquery';\n\nvar index = [];\nvar categories = {\n  Transform: [],\n  Aggregate: [],\n  Filter: [],\n  Trends: [],\n  Time: [],\n  Alias: [],\n  Special: []\n};\n\nfunction addFuncDef(funcDef) {\n  funcDef.params = funcDef.params || [];\n  funcDef.defaultParams = funcDef.defaultParams || [];\n\n  if (funcDef.category) {\n    categories[funcDef.category].push(funcDef);\n  }\n  index[funcDef.name] = funcDef;\n  index[funcDef.shortName || funcDef.name] = funcDef;\n}\n\n// Transform\n\naddFuncDef({\n  name: 'groupBy',\n  category: 'Transform',\n  params: [\n    { name: 'interval', type: 'string'},\n    { name: 'function', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count', 'median'] }\n  ],\n  defaultParams: ['1m', 'avg'],\n});\n\naddFuncDef({\n  name: 'scale',\n  category: 'Transform',\n  params: [\n    { name: 'factor', type: 'float', options: [100, 0.01, 10, -1]}\n  ],\n  defaultParams: [100],\n});\n\naddFuncDef({\n  name: 'offset',\n  category: 'Transform',\n  params: [\n    { name: 'delta', type: 'float', options: [-100, 100]}\n  ],\n  defaultParams: [100],\n});\n\naddFuncDef({\n  name: 'delta',\n  category: 'Transform',\n  params: [],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'rate',\n  category: 'Transform',\n  params: [],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'movingAverage',\n  category: 'Transform',\n  params: [\n    { name: 'factor', type: 'int', options: [6, 10, 60, 100, 600] }\n  ],\n  defaultParams: [10],\n});\n\naddFuncDef({\n  name: 'exponentialMovingAverage',\n  category: 'Transform',\n  params: [\n    { name: 'smoothing', type: 'float', options: [6, 10, 60, 100, 600] }\n  ],\n  defaultParams: [0.2],\n});\n\naddFuncDef({\n  name: 'removeAboveValue',\n  category: 'Transform',\n  params: [\n    {name: 'number', type: 'float'},\n  ],\n  defaultParams: [0],\n});\n\naddFuncDef({\n  name: 'removeBelowValue',\n  category: 'Transform',\n  params: [\n    {name: 'number', type: 'float'},\n  ],\n  defaultParams: [0],\n});\n\naddFuncDef({\n  name: 'transformNull',\n  category: 'Transform',\n  params: [\n    {name: 'number', type: 'float'}\n  ],\n  defaultParams: [0],\n});\n\n// Aggregate\n\naddFuncDef({\n  name: 'sumSeries',\n  category: 'Aggregate',\n  params: [],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'median',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string'}\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'average',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'percentile',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' },\n    { name: 'percent', type: 'float', options: [25, 50, 75, 90, 95, 99, 99.9] }\n  ],\n  defaultParams: ['1m', 95],\n});\n\naddFuncDef({\n  name: 'min',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'max',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'sum',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'count',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'aggregateBy',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' },\n    { name: 'function', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count', 'median'] }\n  ],\n  defaultParams: ['1m', 'avg'],\n});\n\n// Filter\n\naddFuncDef({\n  name: 'top',\n  category: 'Filter',\n  params: [\n    { name: 'number', type: 'int' },\n    { name: 'value', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count', 'median'] }\n  ],\n  defaultParams: [5, 'avg'],\n});\n\naddFuncDef({\n  name: 'bottom',\n  category: 'Filter',\n  params: [\n    { name: 'number', type: 'int' },\n    { name: 'value', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count', 'median'] }\n  ],\n  defaultParams: [5, 'avg'],\n});\n\naddFuncDef({\n  name: 'sortSeries',\n  category: 'Filter',\n  params: [\n    { name: 'direction', type: 'string', options: ['asc', 'desc'] }\n  ],\n  defaultParams: ['asc']\n});\n\n// Trends\n\naddFuncDef({\n  name: 'trendValue',\n  category: 'Trends',\n  params: [\n    { name: 'type', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count'] }\n  ],\n  defaultParams: ['avg'],\n});\n\n// Time\n\naddFuncDef({\n  name: 'timeShift',\n  category: 'Time',\n  params: [\n    { name: 'interval', type: 'string', options: ['24h', '7d', '1M', '+24h', '-24h']}\n  ],\n  defaultParams: ['24h'],\n});\n\n//Alias\n\naddFuncDef({\n  name: 'setAlias',\n  category: 'Alias',\n  params: [\n    { name: 'alias', type: 'string' }\n  ],\n  defaultParams: []\n});\n\naddFuncDef({\n  name: 'setAliasByRegex',\n  category: 'Alias',\n  params: [\n    { name: 'aliasByRegex', type: 'string' }\n  ],\n  defaultParams: []\n});\n\naddFuncDef({\n  name: 'replaceAlias',\n  category: 'Alias',\n  params: [\n    { name: 'regexp', type: 'string' },\n    { name: 'newAlias', type: 'string' }\n  ],\n  defaultParams: ['/(.*)/', '$1']\n});\n\n// Special\naddFuncDef({\n  name: 'consolidateBy',\n  category: 'Special',\n  params: [\n    { name: 'type', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count'] }\n  ],\n  defaultParams: ['avg'],\n});\n\n_.each(categories, function(funcList, catName) {\n  categories[catName] = _.sortBy(funcList, 'name');\n});\n\nclass FuncInstance {\n  constructor(funcDef, params) {\n    this.def = funcDef;\n\n    if (params) {\n      this.params = params;\n    } else {\n      // Create with default params\n      this.params = [];\n      this.params = funcDef.defaultParams.slice(0);\n    }\n\n    this.updateText();\n  }\n\n  bindFunction(metricFunctions) {\n    var func = metricFunctions[this.def.name];\n    if (func) {\n\n      // Bind function arguments\n      var bindedFunc = func;\n      var param;\n      for (var i = 0; i < this.params.length; i++) {\n        param = this.params[i];\n\n        // Convert numeric params\n        if (this.def.params[i].type === 'int' ||\n            this.def.params[i].type === 'float') {\n          param = Number(param);\n        }\n        bindedFunc = _.partial(bindedFunc, param);\n      }\n      return bindedFunc;\n    } else {\n      throw { message: 'Method not found ' + this.def.name };\n    }\n  }\n\n  render(metricExp) {\n    var str = this.def.name + '(';\n    var parameters = _.map(this.params, function(value, index) {\n\n      var paramType = this.def.params[index].type;\n      if (paramType === 'int' ||\n          paramType === 'float' ||\n          paramType === 'value_or_series' ||\n          paramType === 'boolean') {\n        return value;\n      }\n      else if (paramType === 'int_or_interval' && $.isNumeric(value)) {\n        return value;\n      }\n\n      return \"'\" + value + \"'\";\n\n    }, this);\n\n    if (metricExp) {\n      parameters.unshift(metricExp);\n    }\n\n    return str + parameters.join(', ') + ')';\n  }\n\n  _hasMultipleParamsInString(strValue, index) {\n    if (strValue.indexOf(',') === -1) {\n      return false;\n    }\n\n    return this.def.params[index + 1] && this.def.params[index + 1].optional;\n  }\n\n  updateParam(strValue, index) {\n    // handle optional parameters\n    // if string contains ',' and next param is optional, split and update both\n    if (this._hasMultipleParamsInString(strValue, index)) {\n      _.each(strValue.split(','), function(partVal, idx) {\n        this.updateParam(partVal.trim(), idx);\n      }, this);\n      return;\n    }\n\n    if (strValue === '' && this.def.params[index].optional) {\n      this.params.splice(index, 1);\n    }\n    else {\n      this.params[index] = strValue;\n    }\n\n    this.updateText();\n  }\n\n  updateText() {\n    if (this.params.length === 0) {\n      this.text = this.def.name + '()';\n      return;\n    }\n\n    var text = this.def.name + '(';\n    text += this.params.join(', ');\n    text += ')';\n    this.text = text;\n  }\n}\n\nexport function createFuncInstance(funcDef, params) {\n  if (_.isString(funcDef)) {\n    if (!index[funcDef]) {\n      throw { message: 'Method not found ' + name };\n    }\n    funcDef = index[funcDef];\n  }\n  return new FuncInstance(funcDef, params);\n}\n\nexport function getFuncDef(name) {\n  return index[name];\n}\n\nexport function getCategories() {\n  return categories;\n}\n","import _ from 'lodash';\n\nexport const DEFAULT_QUERY_LIMIT = 10000;\nexport const HISTORY_TO_TABLE_MAP = {\n  '0': 'history',\n  '1': 'history_str',\n  '2': 'history_log',\n  '3': 'history_uint',\n  '4': 'history_text'\n};\n\nexport const TREND_TO_TABLE_MAP = {\n  '0': 'trends',\n  '3': 'trends_uint'\n};\n\nexport const consolidateByFunc = {\n  'avg': 'AVG',\n  'min': 'MIN',\n  'max': 'MAX',\n  'sum': 'SUM',\n  'count': 'COUNT'\n};\n\nexport const consolidateByTrendColumns = {\n  'avg': 'value_avg',\n  'min': 'value_min',\n  'max': 'value_max',\n  'sum': 'num*value_avg' // sum of sums inside the one-hour trend period\n};\n\n/**\n * Base class for external history database connectors. Subclasses should implement `getHistory()`, `getTrends()` and\n * `testDataSource()` methods, which describe how to fetch data from source other than Zabbix API.\n */\nexport class DBConnector {\n  constructor(options, datasourceSrv) {\n    this.datasourceSrv = datasourceSrv;\n    this.datasourceId = options.datasourceId;\n    this.datasourceName = options.datasourceName;\n    this.datasourceTypeId = null;\n    this.datasourceTypeName = null;\n  }\n\n  static loadDatasource(dsId, dsName, datasourceSrv) {\n    if (!dsName && dsId !== undefined) {\n      let ds = _.find(datasourceSrv.getAll(), {'id': dsId});\n      if (!ds) {\n        return Promise.reject(`Data Source with ID ${dsId} not found`);\n      }\n      dsName = ds.name;\n    }\n    if (dsName) {\n      return datasourceSrv.loadDatasource(dsName);\n    } else {\n      return Promise.reject(`Data Source name should be specified`);\n    }\n  }\n\n  loadDBDataSource() {\n    return DBConnector.loadDatasource(this.datasourceId, this.datasourceName, this.datasourceSrv)\n    .then(ds => {\n      this.datasourceTypeId = ds.meta.id;\n      this.datasourceTypeName = ds.meta.name;\n      if (!this.datasourceName) {\n        this.datasourceName = ds.name;\n      }\n      if (!this.datasourceId) {\n        this.datasourceId = ds.id;\n      }\n      return ds;\n    });\n  }\n\n  /**\n   * Send test request to datasource in order to ensure it's working.\n   */\n  testDataSource() {\n    throw new ZabbixNotImplemented('testDataSource()');\n  }\n\n  /**\n   * Get history data from external sources.\n   */\n  getHistory() {\n    throw new ZabbixNotImplemented('getHistory()');\n  }\n\n  /**\n   * Get trends data from external sources.\n   */\n  getTrends() {\n    throw new ZabbixNotImplemented('getTrends()');\n  }\n\n  handleGrafanaTSResponse(history, items, addHostName = true) {\n    return convertGrafanaTSResponse(history, items, addHostName);\n  }\n}\n\n// Define Zabbix DB Connector exception type for non-implemented methods\nexport class ZabbixNotImplemented {\n  constructor(methodName) {\n    this.code = null;\n    this.name = 'ZabbixNotImplemented';\n    this.message = `Zabbix DB Connector Error: method ${methodName || ''} should be implemented in subclass of DBConnector`;\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n\n/**\n * Converts time series returned by the data source into format that Grafana expects\n * time_series is Array of series:\n * ```\n * [{\n *     name: string,\n *     points: Array<[value: number, timestamp: number]>\n * }]\n * ```\n */\nfunction convertGrafanaTSResponse(time_series, items, addHostName) {\n  //uniqBy is needed to deduplicate\n  var hosts = _.uniqBy(_.flatten(_.map(items, 'hosts')), 'hostid');\n  let grafanaSeries = _.map(_.compact(time_series), series => {\n    let itemid = series.name;\n    var item = _.find(items, {'itemid': itemid});\n    var alias = item.name;\n    //only when actual multi hosts selected\n    if (_.keys(hosts).length > 1 && addHostName) {\n      var host = _.find(hosts, {'hostid': item.hostid});\n      alias = host.name + \": \" + alias;\n    }\n    // CachingProxy deduplicates requests and returns one time series for equal queries.\n    // Clone is needed to prevent changing of series object shared between all targets.\n    let datapoints = _.cloneDeep(series.points);\n    return {\n      target: alias,\n      datapoints: datapoints\n    };\n  });\n\n  return _.sortBy(grafanaSeries, 'target');\n}\n\nconst defaults = {\n  DBConnector,\n  DEFAULT_QUERY_LIMIT,\n  HISTORY_TO_TABLE_MAP,\n  TREND_TO_TABLE_MAP,\n  consolidateByFunc,\n  consolidateByTrendColumns\n};\n\nexport default defaults;\n","import _ from 'lodash';\nimport TableModel from 'grafana/app/core/table_model';\nimport * as c from './constants';\n\n/**\n * Convert Zabbix API history.get response to Grafana format\n *\n * @return {Array}            Array of timeseries in Grafana format\n *                            {\n *                               target: \"Metric name\",\n *                               datapoints: [[<value>, <unixtime>], ...]\n *                            }\n */\nfunction convertHistory(history, items, addHostName, convertPointCallback) {\n  /**\n   * Response should be in the format:\n   * data: [\n   *          {\n   *             target: \"Metric name\",\n   *             datapoints: [[<value>, <unixtime>], ...]\n   *          }, ...\n   *       ]\n   */\n\n  // Group history by itemid\n  var grouped_history = _.groupBy(history, 'itemid');\n  var hosts = _.uniqBy(_.flatten(_.map(items, 'hosts')), 'hostid');  //uniqBy is needed to deduplicate\n\n  return _.map(grouped_history, function(hist, itemid) {\n    var item = _.find(items, {'itemid': itemid});\n    var alias = item.name;\n    if (_.keys(hosts).length > 1 && addHostName) {   //only when actual multi hosts selected\n      var host = _.find(hosts, {'hostid': item.hostid});\n      alias = host.name + \": \" + alias;\n    }\n    return {\n      target: alias,\n      datapoints: _.map(hist, convertPointCallback)\n    };\n  });\n}\n\nfunction sortTimeseries(timeseries) {\n  // Sort trend data, issue #202\n  _.forEach(timeseries, series => {\n    series.datapoints = _.sortBy(series.datapoints, point => point[c.DATAPOINT_TS]);\n  });\n  return timeseries;\n}\n\nfunction handleHistory(history, items, addHostName = true) {\n  return convertHistory(history, items, addHostName, convertHistoryPoint);\n}\n\nfunction handleTrends(history, items, valueType, addHostName = true) {\n  var convertPointCallback = _.partial(convertTrendPoint, valueType);\n  return convertHistory(history, items, addHostName, convertPointCallback);\n}\n\nfunction handleText(history, items, target, addHostName = true) {\n  let convertTextCallback = _.partial(convertText, target);\n  return convertHistory(history, items, addHostName, convertTextCallback);\n}\n\nfunction handleHistoryAsTable(history, items, target) {\n  let table = new TableModel();\n  table.addColumn({text: 'Host'});\n  table.addColumn({text: 'Item'});\n  table.addColumn({text: 'Key'});\n  table.addColumn({text: 'Last value'});\n\n  let grouped_history = _.groupBy(history, 'itemid');\n  _.each(items, (item) => {\n    let itemHistory = grouped_history[item.itemid] || [];\n    let lastPoint = _.last(itemHistory);\n    let lastValue = lastPoint ? lastPoint.value : null;\n\n    if(target.options.skipEmptyValues && (!lastValue || lastValue === '')) {\n      return;\n    }\n\n    // Regex-based extractor\n    if (target.textFilter) {\n      lastValue = extractText(lastValue, target.textFilter, target.useCaptureGroups);\n    }\n\n    let host = _.first(item.hosts);\n    host = host ? host.name : \"\";\n\n    table.rows.push([\n      host, item.name, item.key_, lastValue\n    ]);\n  });\n\n  return table;\n}\n\nfunction convertText(target, point) {\n  let value = point.value;\n\n  // Regex-based extractor\n  if (target.textFilter) {\n    value = extractText(point.value, target.textFilter, target.useCaptureGroups);\n  }\n\n  return [\n    value,\n    point.clock * 1000 + Math.round(point.ns / 1000000)\n  ];\n}\n\nfunction extractText(str, pattern, useCaptureGroups) {\n  let extractPattern = new RegExp(pattern);\n  let extractedValue = extractPattern.exec(str);\n  if (extractedValue) {\n    if (useCaptureGroups) {\n      extractedValue = extractedValue[1];\n    } else {\n      extractedValue = extractedValue[0];\n    }\n  }\n  return extractedValue;\n}\n\nfunction handleSLAResponse(itservice, slaProperty, slaObject) {\n  var targetSLA = slaObject[itservice.serviceid].sla[0];\n  if (slaProperty.property === 'status') {\n    var targetStatus = parseInt(slaObject[itservice.serviceid].status);\n    return {\n      target: itservice.name + ' ' + slaProperty.name,\n      datapoints: [\n        [targetStatus, targetSLA.to * 1000]\n      ]\n    };\n  } else {\n    return {\n      target: itservice.name + ' ' + slaProperty.name,\n      datapoints: [\n        [targetSLA[slaProperty.property], targetSLA.from * 1000],\n        [targetSLA[slaProperty.property], targetSLA.to * 1000]\n      ]\n    };\n  }\n}\n\nfunction handleTriggersResponse(triggers, groups, timeRange) {\n  if (_.isNumber(triggers)) {\n    return {\n      target: \"triggers count\",\n      datapoints: [\n        [triggers, timeRange[1] * 1000]\n      ]\n    };\n  } else {\n    const stats = getTriggerStats(triggers);\n    const groupNames = _.map(groups, 'name');\n    let table = new TableModel();\n    table.addColumn({text: 'Host group'});\n    _.each(_.orderBy(c.TRIGGER_SEVERITY, ['val'], ['desc']), (severity) => {\n      table.addColumn({text: severity.text});\n    });\n    _.each(stats, (severity_stats, group) => {\n      if (_.includes(groupNames, group)) {\n        let row = _.map(_.orderBy(_.toPairs(severity_stats), (s) => s[0], ['desc']), (s) => s[1]);\n        row = _.concat([group], ...row);\n        table.rows.push(row);\n      }\n    });\n    return table;\n  }\n}\n\nfunction getTriggerStats(triggers) {\n  let groups = _.uniq(_.flattenDeep(_.map(triggers, (trigger) => _.map(trigger.groups, 'name'))));\n  // let severity = _.map(c.TRIGGER_SEVERITY, 'text');\n  let stats = {};\n  _.each(groups, (group) => {\n    stats[group] = {0:0, 1:0, 2:0, 3:0, 4:0, 5:0}; // severity:count\n  });\n  _.each(triggers, (trigger) => {\n    _.each(trigger.groups, (group) => {\n      stats[group.name][trigger.priority]++;\n    });\n  });\n  return stats;\n}\n\nfunction convertHistoryPoint(point) {\n  // Value must be a number for properly work\n  return [\n    Number(point.value),\n    point.clock * 1000 + Math.round(point.ns / 1000000)\n  ];\n}\n\nfunction convertTrendPoint(valueType, point) {\n  var value;\n  switch (valueType) {\n    case \"min\":\n      value = point.value_min;\n      break;\n    case \"max\":\n      value = point.value_max;\n      break;\n    case \"avg\":\n      value = point.value_avg;\n      break;\n    case \"sum\":\n      value = point.value_sum;\n      break;\n    case \"count\":\n      value = point.value_count;\n      break;\n    default:\n      value = point.value_avg;\n  }\n\n  return [\n    Number(value),\n    point.clock * 1000\n  ];\n}\n\nexport default {\n  handleHistory,\n  convertHistory,\n  handleTrends,\n  handleText,\n  handleHistoryAsTable,\n  handleSLAResponse,\n  handleTriggersResponse,\n  sortTimeseries\n};\n\n// Fix for backward compatibility with lodash 2.4\nif (!_.uniqBy) {_.uniqBy = _.uniq;}\n","/**\n * General Zabbix API methods\n */\n\nexport class ZabbixAPICore {\n\n  /** @ngInject */\n  constructor(backendSrv) {\n    this.backendSrv = backendSrv;\n  }\n\n  /**\n   * Request data from Zabbix API\n   * @return {object}  response.result\n   */\n  request(api_url, method, params, options, auth) {\n    let requestData = {\n      jsonrpc: '2.0',\n      method: method,\n      params: params,\n      id: 1\n    };\n\n    if (auth === \"\") {\n      // Reject immediately if not authenticated\n      return Promise.reject(new ZabbixAPIError({data: \"Not authorised.\"}));\n    } else if (auth) {\n      // Set auth parameter only if it needed\n      requestData.auth = auth;\n    }\n\n    let requestOptions = {\n      method: 'POST',\n      url: api_url,\n      data: requestData,\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    };\n\n    // Set request options for basic auth\n    if (options.basicAuth || options.withCredentials) {\n      requestOptions.withCredentials = true;\n    }\n    if (options.basicAuth) {\n      requestOptions.headers.Authorization = options.basicAuth;\n    }\n\n    return this.datasourceRequest(requestOptions);\n  }\n\n  datasourceRequest(requestOptions) {\n    return this.backendSrv.datasourceRequest(requestOptions)\n    .then((response) => {\n      if (!response.data) {\n        return Promise.reject(new ZabbixAPIError({data: \"General Error, no data\"}));\n      } else if (response.data.error) {\n\n        // Handle Zabbix API errors\n        return Promise.reject(new ZabbixAPIError(response.data.error));\n      }\n\n      // Success\n      return response.data.result;\n    });\n  }\n\n  /**\n   * Get authentication token.\n   * @return {string}  auth token\n   */\n  login(api_url, username, password, options) {\n    let params = {\n      user: username,\n      password: password\n    };\n    return this.request(api_url, 'user.login', params, options, null);\n  }\n\n  /**\n   * Get Zabbix API version\n   * Matches the version of Zabbix starting from Zabbix 2.0.4\n   */\n  getVersion(api_url, options) {\n    return this.request(api_url, 'apiinfo.version', [], options);\n  }\n}\n\n// Define zabbix API exception type\nexport class ZabbixAPIError {\n  constructor(error) {\n    this.code = error.code || null;\n    this.name = error.message || \"\";\n    this.data = error.data || \"\";\n    this.message = \"Zabbix API Error: \" + this.name + \" \" + this.data;\n  }\n\n  toString() {\n    return this.name + \" \" + this.data;\n  }\n}\n","import { loadPluginCss } from 'grafana/app/plugins/sdk';\nimport { ZabbixDatasource } from './datasource';\nimport { ZabbixQueryController } from './query.controller';\nimport { ZabbixDSConfigController } from './config.controller';\nimport './zabbixAlerting.service.js';\nimport './add-metric-function.directive';\nimport './metric-function-editor.directive';\n\nclass ZabbixQueryOptionsController {}\nZabbixQueryOptionsController.templateUrl = 'datasource-zabbix/partials/query.options.html';\n\nclass ZabbixAnnotationsQueryController {}\nZabbixAnnotationsQueryController.templateUrl = 'datasource-zabbix/partials/annotations.editor.html';\n\nZabbixQueryController.templateUrl = 'datasource-zabbix/partials/query.editor.html';\nZabbixDSConfigController.templateUrl = 'datasource-zabbix/partials/config.html';\n\nloadPluginCss({\n  dark: 'plugins/alexanderzobnin-zabbix-app/css/grafana-zabbix.dark.css',\n  light: 'plugins/alexanderzobnin-zabbix-app/css/grafana-zabbix.light.css'\n});\n\nexport {\n  ZabbixDatasource as Datasource,\n  ZabbixDSConfigController as ConfigCtrl,\n  ZabbixQueryController as QueryCtrl,\n  ZabbixQueryOptionsController as QueryOptionsCtrl,\n  ZabbixAnnotationsQueryController as AnnotationsQueryCtrl\n};\n","import _ from 'lodash';\nimport config from 'grafana/app/core/config';\nimport * as dateMath from 'grafana/app/core/utils/datemath';\nimport * as utils from './utils';\nimport * as migrations from './migrations';\nimport * as metricFunctions from './metricFunctions';\nimport * as c from './constants';\nimport dataProcessor from './dataProcessor';\nimport responseHandler from './responseHandler';\nimport { Zabbix } from './zabbix/zabbix';\nimport { ZabbixAPIError } from './zabbix/connectors/zabbix_api/zabbixAPICore';\n\nconst DEFAULT_ZABBIX_VERSION = 3;\n\nexport class ZabbixDatasource {\n\n  /** @ngInject */\n  constructor(instanceSettings, templateSrv, backendSrv, datasourceSrv, zabbixAlertingSrv) {\n    this.templateSrv = templateSrv;\n    this.zabbixAlertingSrv = zabbixAlertingSrv;\n\n    this.enableDebugLog = config.buildInfo.env === 'development';\n\n    // Use custom format for template variables\n    this.replaceTemplateVars = _.partial(replaceTemplateVars, this.templateSrv);\n\n    // General data source settings\n    this.name             = instanceSettings.name;\n    this.url              = instanceSettings.url;\n    this.basicAuth        = instanceSettings.basicAuth;\n    this.withCredentials  = instanceSettings.withCredentials;\n\n    const jsonData = migrations.migrateDSConfig(instanceSettings.jsonData);\n\n    // Zabbix API credentials\n    this.username         = jsonData.username;\n    this.password         = jsonData.password;\n\n    // Use trends instead history since specified time\n    this.trends           = jsonData.trends;\n    this.trendsFrom       = jsonData.trendsFrom || '7d';\n    this.trendsRange      = jsonData.trendsRange || '4d';\n\n    // Set cache update interval\n    var ttl = jsonData.cacheTTL || '1h';\n    this.cacheTTL = utils.parseInterval(ttl);\n\n    // Alerting options\n    this.alertingEnabled =     jsonData.alerting;\n    this.addThresholds =       jsonData.addThresholds;\n    this.alertingMinSeverity = jsonData.alertingMinSeverity || c.SEV_WARNING;\n\n    // Other options\n    this.disableReadOnlyUsersAck = jsonData.disableReadOnlyUsersAck;\n    this.zabbixVersion = jsonData.zabbixVersion || DEFAULT_ZABBIX_VERSION;\n\n    // Direct DB Connection options\n    this.enableDirectDBConnection = jsonData.dbConnectionEnable || false;\n    this.dbConnectionDatasourceId = jsonData.dbConnectionDatasourceId;\n    this.dbConnectionDatasourceName = jsonData.dbConnectionDatasourceName;\n    this.dbConnectionRetentionPolicy = jsonData.dbConnectionRetentionPolicy;\n\n    let zabbixOptions = {\n      url: this.url,\n      username: this.username,\n      password: this.password,\n      basicAuth: this.basicAuth,\n      withCredentials: this.withCredentials,\n      zabbixVersion: this.zabbixVersion,\n      cacheTTL: this.cacheTTL,\n      enableDirectDBConnection: this.enableDirectDBConnection,\n      dbConnectionDatasourceId: this.dbConnectionDatasourceId,\n      dbConnectionDatasourceName: this.dbConnectionDatasourceName,\n      dbConnectionRetentionPolicy: this.dbConnectionRetentionPolicy,\n    };\n\n    this.zabbix = new Zabbix(zabbixOptions, datasourceSrv, backendSrv);\n  }\n\n  ////////////////////////\n  // Datasource methods //\n  ////////////////////////\n\n  /**\n   * Query panel data. Calls for each panel in dashboard.\n   * @param  {Object} options   Contains time range, targets and other info.\n   * @return {Object} Grafana metrics object with timeseries data for each target.\n   */\n  query(options) {\n    // Get alerts for current panel\n    if (this.alertingEnabled) {\n      this.alertQuery(options).then(alert => {\n        this.zabbixAlertingSrv.setPanelAlertState(options.panelId, alert.state);\n\n        this.zabbixAlertingSrv.removeZabbixThreshold(options.panelId);\n        if (this.addThresholds) {\n          _.forEach(alert.thresholds, threshold => {\n            this.zabbixAlertingSrv.setPanelThreshold(options.panelId, threshold);\n          });\n        }\n      });\n    }\n\n    // Create request for each target\n    let promises = _.map(options.targets, t => {\n      // Don't request for hidden targets\n      if (t.hide) {\n        return [];\n      }\n\n      let timeFrom = Math.ceil(dateMath.parse(options.range.from) / 1000);\n      let timeTo = Math.ceil(dateMath.parse(options.range.to) / 1000);\n\n      // Prevent changes of original object\n      let target = _.cloneDeep(t);\n\n      // Migrate old targets\n      target = migrations.migrate(target);\n      this.replaceTargetVariables(target, options);\n\n      // Apply Time-related functions (timeShift(), etc)\n      let timeFunctions = bindFunctionDefs(target.functions, 'Time');\n      if (timeFunctions.length) {\n        const [time_from, time_to] = utils.sequence(timeFunctions)([timeFrom, timeTo]);\n        timeFrom = time_from;\n        timeTo = time_to;\n      }\n      let timeRange = [timeFrom, timeTo];\n\n      let useTrends = this.isUseTrends(timeRange);\n\n      // Metrics or Text query mode\n      if (!target.mode || target.mode === c.MODE_METRICS || target.mode === c.MODE_TEXT) {\n        // Don't request undefined targets\n        if (!target.group || !target.host || !target.item) {\n          return [];\n        }\n\n        if (!target.mode || target.mode === c.MODE_METRICS) {\n          return this.queryNumericData(target, timeRange, useTrends, options);\n        } else if (target.mode === c.MODE_TEXT) {\n          return this.queryTextData(target, timeRange);\n        }\n      } else if (target.mode === c.MODE_ITEMID) {\n        // Item ID mode\n        if (!target.itemids) {\n          return [];\n        }\n        return this.queryItemIdData(target, timeRange, useTrends, options);\n      } else if (target.mode === c.MODE_ITSERVICE) {\n        // IT services mode\n        return this.queryITServiceData(target, timeRange, options);\n      } else if (target.mode === c.MODE_TRIGGERS) {\n        // Triggers mode\n        return this.queryTriggersData(target, timeRange);\n      } else {\n        return [];\n      }\n    });\n\n    // Data for panel (all targets)\n    return Promise.all(_.flatten(promises))\n      .then(_.flatten)\n      .then(data => {\n        return { data: data };\n      });\n  }\n\n  /**\n   * Query target data for Metrics mode\n   */\n  queryNumericData(target, timeRange, useTrends, options) {\n    let queryStart, queryEnd;\n    let getItemOptions = {\n      itemtype: 'num'\n    };\n    return this.zabbix.getItemsFromTarget(target, getItemOptions)\n    .then(items => {\n      queryStart = new Date().getTime();\n      return this.queryNumericDataForItems(items, target, timeRange, useTrends, options);\n    }).then(result => {\n      queryEnd = new Date().getTime();\n      if (this.enableDebugLog) {\n        console.debug(`Datasource::Performance Query Time (${this.name}): ${queryEnd - queryStart}`);\n      }\n      return result;\n    });\n  }\n\n  /**\n   * Query history for numeric items\n   */\n  queryNumericDataForItems(items, target, timeRange, useTrends, options) {\n    let getHistoryPromise;\n    options.valueType = this.getTrendValueType(target);\n    options.consolidateBy = getConsolidateBy(target) || options.valueType;\n\n    if (useTrends) {\n      getHistoryPromise = this.zabbix.getTrends(items, timeRange, options);\n    } else {\n      getHistoryPromise = this.zabbix.getHistoryTS(items, timeRange, options);\n    }\n\n    return getHistoryPromise\n    .then(timeseries => this.applyDataProcessingFunctions(timeseries, target))\n    .then(timeseries => downsampleSeries(timeseries, options));\n  }\n\n  getTrendValueType(target) {\n    // Find trendValue() function and get specified trend value\n    var trendFunctions = _.map(metricFunctions.getCategories()['Trends'], 'name');\n    var trendValueFunc = _.find(target.functions, func => {\n      return _.includes(trendFunctions, func.def.name);\n    });\n    return trendValueFunc ? trendValueFunc.params[0] : \"avg\";\n  }\n\n  applyDataProcessingFunctions(timeseries_data, target) {\n    let transformFunctions   = bindFunctionDefs(target.functions, 'Transform');\n    let aggregationFunctions = bindFunctionDefs(target.functions, 'Aggregate');\n    let filterFunctions      = bindFunctionDefs(target.functions, 'Filter');\n    let aliasFunctions       = bindFunctionDefs(target.functions, 'Alias');\n\n    // Apply transformation functions\n    timeseries_data = _.cloneDeep(_.map(timeseries_data, timeseries => {\n      timeseries.datapoints = utils.sequence(transformFunctions)(timeseries.datapoints);\n      return timeseries;\n    }));\n\n    // Apply filter functions\n    if (filterFunctions.length) {\n      timeseries_data = utils.sequence(filterFunctions)(timeseries_data);\n    }\n\n    // Apply aggregations\n    if (aggregationFunctions.length) {\n      let dp = _.map(timeseries_data, 'datapoints');\n      dp = utils.sequence(aggregationFunctions)(dp);\n\n      let aggFuncNames = _.map(metricFunctions.getCategories()['Aggregate'], 'name');\n      let lastAgg = _.findLast(target.functions, func => {\n        return _.includes(aggFuncNames, func.def.name);\n      });\n\n      timeseries_data = [{\n        target: lastAgg.text,\n        datapoints: dp\n      }];\n    }\n\n    // Apply alias functions\n    _.forEach(timeseries_data, utils.sequence(aliasFunctions));\n\n    // Apply Time-related functions (timeShift(), etc)\n    // Find timeShift() function and get specified trend value\n    this.applyTimeShiftFunction(timeseries_data, target);\n\n    return timeseries_data;\n  }\n\n  applyTimeShiftFunction(timeseries_data, target) {\n    // Find timeShift() function and get specified interval\n    let timeShiftFunc = _.find(target.functions, (func) => {\n      return func.def.name === 'timeShift';\n    });\n    if (timeShiftFunc) {\n      let shift = timeShiftFunc.params[0];\n      _.forEach(timeseries_data, (series) => {\n        series.datapoints = dataProcessor.unShiftTimeSeries(shift, series.datapoints);\n      });\n    }\n  }\n\n  /**\n   * Query target data for Text mode\n   */\n  queryTextData(target, timeRange) {\n    let options = {\n      itemtype: 'text'\n    };\n    return this.zabbix.getItemsFromTarget(target, options)\n    .then(items => {\n      return this.zabbix.getHistoryText(items, timeRange, target);\n    });\n  }\n\n  /**\n   * Query target data for Item ID mode\n   */\n  queryItemIdData(target, timeRange, useTrends, options) {\n    let itemids = target.itemids;\n    itemids = this.templateSrv.replace(itemids, options.scopedVars, zabbixItemIdsTemplateFormat);\n    itemids = _.map(itemids.split(','), itemid => itemid.trim());\n\n    if (!itemids) {\n      return [];\n    }\n\n    return this.zabbix.getItemsByIDs(itemids)\n    .then(items => {\n      return this.queryNumericDataForItems(items, target, timeRange, useTrends, options);\n    });\n  }\n\n  /**\n   * Query target data for IT Services mode\n   */\n  queryITServiceData(target, timeRange, options) {\n    // Don't show undefined and hidden targets\n    if (target.hide || (!target.itservice && !target.itServiceFilter) || !target.slaProperty) {\n      return [];\n    }\n\n    let itServiceFilter;\n    options.isOldVersion = target.itservice && !target.itServiceFilter;\n\n    if (options.isOldVersion) {\n      // Backward compatibility\n      itServiceFilter = '/.*/';\n    } else {\n      itServiceFilter = this.replaceTemplateVars(target.itServiceFilter, options.scopedVars);\n    }\n\n    return this.zabbix.getITServices(itServiceFilter)\n    .then(itservices => {\n      return this.zabbix.getSLA(itservices, timeRange, target, options);\n    });\n  }\n\n  queryTriggersData(target, timeRange) {\n    let [timeFrom, timeTo] = timeRange;\n    return this.zabbix.getHostsFromTarget(target)\n    .then(results => {\n      let [hosts, apps] = results;\n      if (hosts.length) {\n        let hostids = _.map(hosts, 'hostid');\n        let appids = _.map(apps, 'applicationid');\n        let options = {\n          minSeverity: target.triggers.minSeverity,\n          acknowledged: target.triggers.acknowledged,\n          count: target.triggers.count,\n          timeFrom: timeFrom,\n          timeTo: timeTo\n        };\n        const groupFilter = target.group.filter;\n        return Promise.all([\n          this.zabbix.getHostAlerts(hostids, appids, options),\n          this.zabbix.getGroups(groupFilter)\n        ])\n        .then(([triggers, groups]) => {\n          return responseHandler.handleTriggersResponse(triggers, groups, timeRange);\n        });\n      } else {\n        return Promise.resolve([]);\n      }\n    });\n  }\n\n  /**\n   * Test connection to Zabbix API and external history DB.\n   */\n  testDatasource() {\n    return this.zabbix.testDataSource()\n    .then(result => {\n      const { zabbixVersion, dbConnectorStatus } = result;\n      let message = `Zabbix API version: ${zabbixVersion}`;\n      if (dbConnectorStatus) {\n        message += `, DB connector type: ${dbConnectorStatus.dsType}`;\n      }\n      return {\n        status: \"success\",\n        title: \"Success\",\n        message: message\n      };\n    })\n    .catch(error => {\n      if (error instanceof ZabbixAPIError) {\n        return {\n          status: \"error\",\n          title: error.message,\n          message: error.message\n        };\n      } else if (error.data && error.data.message) {\n        return {\n          status: \"error\",\n          title: \"Connection failed\",\n          message: \"Connection failed: \" + error.data.message\n        };\n      } else if (typeof(error) === 'string') {\n        return {\n          status: \"error\",\n          title: \"Connection failed\",\n          message: \"Connection failed: \" + error\n        };\n      } else {\n        console.log(error);\n        return {\n          status: \"error\",\n          title: \"Connection failed\",\n          message: \"Could not connect to given url\"\n        };\n      }\n    });\n  }\n\n  /**\n   * Get Zabbix version\n   */\n  getVersion() {\n    return this.zabbix.getVersion()\n    .then(version => {\n      const zabbixVersion = utils.parseVersion(version);\n      if (!zabbixVersion) {\n        return null;\n      }\n      return zabbixVersion.major;\n    });\n  }\n\n  ////////////////\n  // Templating //\n  ////////////////\n\n  /**\n   * Find metrics from templated request.\n   *\n   * @param  {string} query Query from Templating\n   * @return {string}       Metric name - group, host, app or item or list\n   *                        of metrics in \"{metric1,metcic2,...,metricN}\" format.\n   */\n  metricFindQuery(query) {\n    let result;\n    let parts = [];\n\n    // Split query. Query structure: group.host.app.item\n    _.each(utils.splitTemplateQuery(query), part => {\n      part = this.replaceTemplateVars(part, {});\n\n      // Replace wildcard to regex\n      if (part === '*') {\n        part = '/.*/';\n      }\n      parts.push(part);\n    });\n    let template = _.zipObject(['group', 'host', 'app', 'item'], parts);\n\n    // Get items\n    if (parts.length === 4) {\n      // Search for all items, even it's not belong to any application\n      if (template.app === '/.*/') {\n        template.app = '';\n      }\n      result = this.zabbix.getItems(template.group, template.host, template.app, template.item);\n    } else if (parts.length === 3) {\n      // Get applications\n      result = this.zabbix.getApps(template.group, template.host, template.app);\n    } else if (parts.length === 2) {\n      // Get hosts\n      result = this.zabbix.getHosts(template.group, template.host);\n    } else if (parts.length === 1) {\n      // Get groups\n      result = this.zabbix.getGroups(template.group);\n    } else {\n      result = Promise.resolve([]);\n    }\n\n    return result.then(metrics => {\n      return _.map(metrics, formatMetric);\n    });\n  }\n\n  /////////////////\n  // Annotations //\n  /////////////////\n\n  annotationQuery(options) {\n    const timeRange = options.range || options.rangeRaw;\n    const timeFrom = Math.ceil(dateMath.parse(timeRange.from) / 1000);\n    const timeTo = Math.ceil(dateMath.parse(timeRange.to) / 1000);\n    var annotation = options.annotation;\n    var showOkEvents = annotation.showOkEvents ? c.SHOW_ALL_EVENTS : c.SHOW_OK_EVENTS;\n\n    // Show all triggers\n    let triggersOptions = {\n      showTriggers: c.SHOW_ALL_TRIGGERS,\n      hideHostsInMaintenance: false\n    };\n\n    var getTriggers = this.zabbix.getTriggers(this.replaceTemplateVars(annotation.group, {}),\n                                              this.replaceTemplateVars(annotation.host, {}),\n                                              this.replaceTemplateVars(annotation.application, {}),\n                                              triggersOptions);\n\n    return getTriggers.then(triggers => {\n\n      // Filter triggers by description\n      let triggerName = this.replaceTemplateVars(annotation.trigger, {});\n      if (utils.isRegex(triggerName)) {\n        triggers = _.filter(triggers, trigger => {\n          return utils.buildRegex(triggerName).test(trigger.description);\n        });\n      } else if (triggerName) {\n        triggers = _.filter(triggers, trigger => {\n          return trigger.description === triggerName;\n        });\n      }\n\n      // Remove events below the chose severity\n      triggers = _.filter(triggers, trigger => {\n        return Number(trigger.priority) >= Number(annotation.minseverity);\n      });\n\n      var objectids = _.map(triggers, 'triggerid');\n      return this.zabbix\n        .getEvents(objectids, timeFrom, timeTo, showOkEvents)\n        .then(events => {\n          var indexedTriggers = _.keyBy(triggers, 'triggerid');\n\n          // Hide acknowledged events if option enabled\n          if (annotation.hideAcknowledged) {\n            events = _.filter(events, event => {\n              return !event.acknowledges.length;\n            });\n          }\n\n          return _.map(events, event => {\n            let tags;\n            if (annotation.showHostname) {\n              tags = _.map(event.hosts, 'name');\n            }\n\n            // Show event type (OK or Problem)\n            let title = Number(event.value) ? 'Problem' : 'OK';\n\n            let formatted_acknowledges = utils.formatAcknowledges(event.acknowledges);\n            return {\n              annotation: annotation,\n              time: event.clock * 1000,\n              title: title,\n              tags: tags,\n              text: indexedTriggers[event.objectid].description + formatted_acknowledges\n            };\n          });\n        });\n    });\n  }\n\n  /**\n   * Get triggers and its details for panel's targets\n   * Returns alert state ('ok' if no fired triggers, or 'alerting' if at least 1 trigger is fired)\n   * or empty object if no related triggers are finded.\n   */\n  alertQuery(options) {\n    let enabled_targets = filterEnabledTargets(options.targets);\n    let getPanelItems = _.map(enabled_targets, t => {\n      let target = _.cloneDeep(t);\n      target = migrations.migrate(target);\n      this.replaceTargetVariables(target, options);\n      return this.zabbix.getItemsFromTarget(target, {itemtype: 'num'});\n    });\n\n    return Promise.all(getPanelItems)\n    .then(results => {\n      let items = _.flatten(results);\n      let itemids = _.map(items, 'itemid');\n\n      if (itemids.length === 0) {\n        return [];\n      }\n      return this.zabbix.getAlerts(itemids);\n    })\n    .then(triggers => {\n      triggers = _.filter(triggers, trigger => {\n        return trigger.priority >= this.alertingMinSeverity;\n      });\n\n      if (!triggers || triggers.length === 0) {\n        return {};\n      }\n\n      let state = 'ok';\n\n      let firedTriggers = _.filter(triggers, {value: '1'});\n      if (firedTriggers.length) {\n        state = 'alerting';\n      }\n\n      let thresholds = _.map(triggers, trigger => {\n        return getTriggerThreshold(trigger.expression);\n      });\n\n      return {\n        panelId: options.panelId,\n        state: state,\n        thresholds: thresholds\n      };\n    });\n  }\n\n  // Replace template variables\n  replaceTargetVariables(target, options) {\n    let parts = ['group', 'host', 'application', 'item'];\n    _.forEach(parts, p => {\n      if (target[p] && target[p].filter) {\n        target[p].filter = this.replaceTemplateVars(target[p].filter, options.scopedVars);\n      }\n    });\n    target.textFilter = this.replaceTemplateVars(target.textFilter, options.scopedVars);\n\n    _.forEach(target.functions, func => {\n      func.params = _.map(func.params, param => {\n        if (typeof param === 'number') {\n          return +this.templateSrv.replace(param.toString(), options.scopedVars);\n        } else {\n          return this.templateSrv.replace(param, options.scopedVars);\n        }\n      });\n    });\n  }\n\n  isUseTrends(timeRange) {\n    let [timeFrom, timeTo] = timeRange;\n    let useTrendsFrom = Math.ceil(dateMath.parse('now-' + this.trendsFrom) / 1000);\n    let useTrendsRange = Math.ceil(utils.parseInterval(this.trendsRange) / 1000);\n    let useTrends = this.trends && (\n      (timeFrom < useTrendsFrom) ||\n      (timeTo - timeFrom > useTrendsRange)\n    );\n    return useTrends;\n  }\n}\n\nfunction bindFunctionDefs(functionDefs, category) {\n  var aggregationFunctions = _.map(metricFunctions.getCategories()[category], 'name');\n  var aggFuncDefs = _.filter(functionDefs, function(func) {\n    return _.includes(aggregationFunctions, func.def.name);\n  });\n\n  return _.map(aggFuncDefs, function(func) {\n    var funcInstance = metricFunctions.createFuncInstance(func.def, func.params);\n    return funcInstance.bindFunction(dataProcessor.metricFunctions);\n  });\n}\n\nfunction getConsolidateBy(target) {\n  let consolidateBy;\n  let funcDef = _.find(target.functions, func => {\n    return func.def.name === 'consolidateBy';\n  });\n  if (funcDef && funcDef.params && funcDef.params.length) {\n    consolidateBy = funcDef.params[0];\n  }\n  return consolidateBy;\n}\n\nfunction downsampleSeries(timeseries_data, options) {\n  let defaultAgg = dataProcessor.aggregationFunctions['avg'];\n  let consolidateByFunc = dataProcessor.aggregationFunctions[options.consolidateBy] || defaultAgg;\n  return _.map(timeseries_data, timeseries => {\n    if (timeseries.datapoints.length > options.maxDataPoints) {\n      timeseries.datapoints = dataProcessor\n        .groupBy(options.interval, consolidateByFunc, timeseries.datapoints);\n    }\n    return timeseries;\n  });\n}\n\nfunction formatMetric(metricObj) {\n  return {\n    text: metricObj.name,\n    expandable: false\n  };\n}\n\n/**\n * Custom formatter for template variables.\n * Default Grafana \"regex\" formatter returns\n * value1|value2\n * This formatter returns\n * (value1|value2)\n * This format needed for using in complex regex with\n * template variables, for example\n * /CPU $cpu_item.*time/ where $cpu_item is system,user,iowait\n */\nexport function zabbixTemplateFormat(value) {\n  if (typeof value === 'string') {\n    return utils.escapeRegex(value);\n  }\n\n  var escapedValues = _.map(value, utils.escapeRegex);\n  return '(' + escapedValues.join('|') + ')';\n}\n\nfunction zabbixItemIdsTemplateFormat(value) {\n  if (typeof value === 'string') {\n    return value;\n  }\n  return value.join(',');\n}\n\n/**\n * If template variables are used in request, replace it using regex format\n * and wrap with '/' for proper multi-value work. Example:\n * $variable selected as a, b, c\n * We use filter $variable\n * $variable    -> a|b|c    -> /a|b|c/\n * /$variable/  -> /a|b|c/  -> /a|b|c/\n */\nfunction replaceTemplateVars(templateSrv, target, scopedVars) {\n  var replacedTarget = templateSrv.replace(target, scopedVars, zabbixTemplateFormat);\n  if (target !== replacedTarget && !utils.isRegex(replacedTarget)) {\n    replacedTarget = '/^' + replacedTarget + '$/';\n  }\n  return replacedTarget;\n}\n\nfunction filterEnabledTargets(targets) {\n  return _.filter(targets, target => {\n    return !(target.hide || !target.group || !target.host || !target.item);\n  });\n}\n\nfunction getTriggerThreshold(expression) {\n  let thresholdPattern = /.*[<>=]{1,2}([\\d\\.]+)/;\n  let finded_thresholds = expression.match(thresholdPattern);\n  if (finded_thresholds && finded_thresholds.length >= 2) {\n    let threshold = finded_thresholds[1];\n    threshold = Number(threshold);\n    return threshold;\n  } else {\n    return null;\n  }\n}\n\n// Fix for backward compatibility with lodash 2.4\nif (!_.includes) {_.includes = _.contains;}\nif (!_.keyBy) {_.keyBy = _.indexBy;}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__37__;","import _ from 'lodash';\nimport * as utils from './utils';\nimport ts from './timeseries';\n\nlet downsampleSeries = ts.downsample;\nlet groupBy = ts.groupBy_perf;\nlet groupBy_exported = (interval, groupFunc, datapoints) => groupBy(datapoints, interval, groupFunc);\nlet sumSeries = ts.sumSeries;\nlet delta = ts.delta;\nlet rate = ts.rate;\nlet scale = (factor, datapoints) => ts.scale_perf(datapoints, factor);\nlet offset = (delta, datapoints) => ts.offset(datapoints, delta);\nlet simpleMovingAverage = (n, datapoints) => ts.simpleMovingAverage(datapoints, n);\nlet expMovingAverage = (a, datapoints) => ts.expMovingAverage(datapoints, a);\n\nlet SUM = ts.SUM;\nlet COUNT = ts.COUNT;\nlet AVERAGE = ts.AVERAGE;\nlet MIN = ts.MIN;\nlet MAX = ts.MAX;\nlet MEDIAN = ts.MEDIAN;\nlet PERCENTILE = ts.PERCENTILE;\n\nfunction limit(order, n, orderByFunc, timeseries) {\n  let orderByCallback = aggregationFunctions[orderByFunc];\n  let sortByIteratee = (ts) => {\n    let values = _.map(ts.datapoints, (point) => {\n      return point[0];\n    });\n    return orderByCallback(values);\n  };\n  let sortedTimeseries = _.sortBy(timeseries, sortByIteratee);\n  if (order === 'bottom') {\n    return sortedTimeseries.slice(0, n);\n  } else {\n    return sortedTimeseries.slice(-n);\n  }\n}\n\nfunction removeAboveValue(n, datapoints) {\n  return _.map(datapoints, point => {\n    return [\n      (point[0] > n) ? null : point[0],\n      point[1]\n    ];\n  });\n}\n\nfunction removeBelowValue(n, datapoints) {\n  return _.map(datapoints, point => {\n    return [\n      (point[0] < n) ? null : point[0],\n      point[1]\n    ];\n  });\n}\n\nfunction transformNull(n, datapoints) {\n  return _.map(datapoints, point => {\n    return [\n      (point[0] !== null) ? point[0] : n,\n      point[1]\n    ];\n  });\n}\n\nfunction sortSeries(direction, timeseries) {\n  return _.orderBy(timeseries, [function (ts) {\n    return ts.target.toLowerCase();\n  }], direction);\n}\n\nfunction setAlias(alias, timeseries) {\n  timeseries.target = alias;\n  return timeseries;\n}\n\nfunction replaceAlias(regexp, newAlias, timeseries) {\n  let pattern;\n  if (utils.isRegex(regexp)) {\n    pattern = utils.buildRegex(regexp);\n  } else {\n    pattern = regexp;\n  }\n\n  let alias = timeseries.target.replace(pattern, newAlias);\n  timeseries.target = alias;\n  return timeseries;\n}\n\nfunction setAliasByRegex(alias, timeseries) {\n  timeseries.target = extractText(timeseries.target, alias);\n  return timeseries;\n}\n\nfunction extractText(str, pattern) {\n  var extractPattern = new RegExp(pattern);\n  var extractedValue = extractPattern.exec(str);\n  extractedValue = extractedValue[0];\n  return extractedValue;\n}\n\nfunction groupByWrapper(interval, groupFunc, datapoints) {\n  var groupByCallback = aggregationFunctions[groupFunc];\n  return groupBy(datapoints, interval, groupByCallback);\n}\n\nfunction aggregateByWrapper(interval, aggregateFunc, datapoints) {\n  // Flatten all points in frame and then just use groupBy()\n  const flattenedPoints = ts.flattenDatapoints(datapoints);\n  // groupBy_perf works with sorted series only\n  const sortedPoints = ts.sortByTime(flattenedPoints);\n  let groupByCallback = aggregationFunctions[aggregateFunc];\n  return groupBy(sortedPoints, interval, groupByCallback);\n}\n\nfunction aggregateWrapper(groupByCallback, interval, datapoints) {\n  var flattenedPoints = ts.flattenDatapoints(datapoints);\n  // groupBy_perf works with sorted series only\n  const sortedPoints = ts.sortByTime(flattenedPoints);\n  return groupBy(sortedPoints, interval, groupByCallback);\n}\n\nfunction percentile(interval, n, datapoints) {\n  var flattenedPoints = ts.flattenDatapoints(datapoints);\n  var groupByCallback = _.partial(PERCENTILE, n);\n  return groupBy(flattenedPoints, interval, groupByCallback);\n}\n\nfunction timeShift(interval, range) {\n  let shift = utils.parseTimeShiftInterval(interval) / 1000;\n  return _.map(range, time => {\n    return time - shift;\n  });\n}\n\nfunction unShiftTimeSeries(interval, datapoints) {\n  let unshift = utils.parseTimeShiftInterval(interval);\n  return _.map(datapoints, dp => {\n    return [\n      dp[0],\n      dp[1] + unshift\n    ];\n  });\n}\n\nlet metricFunctions = {\n  groupBy: groupByWrapper,\n  scale: scale,\n  offset: offset,\n  delta: delta,\n  rate: rate,\n  movingAverage: simpleMovingAverage,\n  exponentialMovingAverage: expMovingAverage,\n  transformNull: transformNull,\n  aggregateBy: aggregateByWrapper,\n  // Predefined aggs\n  percentile: percentile,\n  average: _.partial(aggregateWrapper, AVERAGE),\n  min: _.partial(aggregateWrapper, MIN),\n  max: _.partial(aggregateWrapper, MAX),\n  median: _.partial(aggregateWrapper, MEDIAN),\n  sum: _.partial(aggregateWrapper, SUM),\n  count: _.partial(aggregateWrapper, COUNT),\n  sumSeries: sumSeries,\n  removeAboveValue: removeAboveValue,\n  removeBelowValue: removeBelowValue,\n  top: _.partial(limit, 'top'),\n  bottom: _.partial(limit, 'bottom'),\n  sortSeries: sortSeries,\n  timeShift: timeShift,\n  setAlias: setAlias,\n  setAliasByRegex: setAliasByRegex,\n  replaceAlias: replaceAlias\n};\n\nlet aggregationFunctions = {\n  avg: AVERAGE,\n  min: MIN,\n  max: MAX,\n  median: MEDIAN,\n  sum: SUM,\n  count: COUNT\n};\n\nexport default {\n  downsampleSeries: downsampleSeries,\n  groupBy: groupBy_exported,\n  AVERAGE: AVERAGE,\n  MIN: MIN,\n  MAX: MAX,\n  MEDIAN: MEDIAN,\n  SUM: SUM,\n  COUNT: COUNT,\n  unShiftTimeSeries: unShiftTimeSeries,\n\n  get aggregationFunctions() {\n    return aggregationFunctions;\n  },\n\n  get metricFunctions() {\n    return metricFunctions;\n  }\n};\n","/**\n * timeseries.js\n *\n * This module contains functions for working with time series.\n *\n * datapoints - array of points where point is [value, timestamp]. In almost all cases (if other wasn't\n * explicitly said) we assume datapoints are sorted by timestamp. Timestamp is the number of milliseconds\n * since 1 January 1970 00:00:00 UTC.\n *\n */\n\nimport _ from 'lodash';\nimport * as utils from './utils';\n\nconst POINT_VALUE = 0;\nconst POINT_TIMESTAMP = 1;\n\n/**\n * Downsample time series by using given function (avg, min, max).\n */\nfunction downsample(datapoints, time_to, ms_interval, func) {\n  var downsampledSeries = [];\n  var timeWindow = {\n    from: time_to * 1000 - ms_interval,\n    to: time_to * 1000\n  };\n\n  var points_sum = 0;\n  var points_num = 0;\n  var value_avg = 0;\n  var frame = [];\n\n  for (var i = datapoints.length - 1; i >= 0; i -= 1) {\n    if (timeWindow.from < datapoints[i][1] && datapoints[i][1] <= timeWindow.to) {\n      points_sum += datapoints[i][0];\n      points_num++;\n      frame.push(datapoints[i][0]);\n    }\n    else {\n      value_avg = points_num ? points_sum / points_num : 0;\n\n      if (func === \"max\") {\n        downsampledSeries.push([_.max(frame), timeWindow.to]);\n      }\n      else if (func === \"min\") {\n        downsampledSeries.push([_.min(frame), timeWindow.to]);\n      }\n\n      // avg by default\n      else {\n        downsampledSeries.push([value_avg, timeWindow.to]);\n      }\n\n      // Shift time window\n      timeWindow.to = timeWindow.from;\n      timeWindow.from -= ms_interval;\n\n      points_sum = 0;\n      points_num = 0;\n      frame = [];\n\n      // Process point again\n      i++;\n    }\n  }\n  return downsampledSeries.reverse();\n}\n\n/**\n * Group points by given time interval\n * datapoints: [[<value>, <unixtime>], ...]\n */\nfunction groupBy(datapoints, interval, groupByCallback) {\n  var ms_interval = utils.parseInterval(interval);\n\n  // Calculate frame timestamps\n  var frames = _.groupBy(datapoints, function (point) {\n    // Calculate time for group of points\n    return Math.floor(point[1] / ms_interval) * ms_interval;\n  });\n\n  // frame: { '<unixtime>': [[<value>, <unixtime>], ...] }\n  // return [{ '<unixtime>': <value> }, { '<unixtime>': <value> }, ...]\n  var grouped = _.mapValues(frames, function (frame) {\n    var points = _.map(frame, function (point) {\n      return point[0];\n    });\n    return groupByCallback(points);\n  });\n\n  // Convert points to Grafana format\n  return sortByTime(_.map(grouped, function (value, timestamp) {\n    return [Number(value), Number(timestamp)];\n  }));\n}\n\nfunction groupBy_perf(datapoints, interval, groupByCallback) {\n  if (datapoints.length === 0) {\n    return [];\n  }\n\n  let ms_interval = utils.parseInterval(interval);\n  let grouped_series = [];\n  let frame_values = [];\n  let frame_value;\n  let frame_ts = datapoints.length ? getPointTimeFrame(datapoints[0][POINT_TIMESTAMP], ms_interval) : 0;\n  let point_frame_ts = frame_ts;\n  let point;\n\n  for (let i=0; i < datapoints.length; i++) {\n    point = datapoints[i];\n    point_frame_ts = getPointTimeFrame(point[POINT_TIMESTAMP], ms_interval);\n    if (point_frame_ts === frame_ts) {\n      frame_values.push(point[POINT_VALUE]);\n    } else if (point_frame_ts > frame_ts) {\n      frame_value = groupByCallback(frame_values);\n      grouped_series.push([frame_value, frame_ts]);\n\n      // Move frame window to next non-empty interval and fill empty by null\n      frame_ts += ms_interval;\n      while (frame_ts < point_frame_ts) {\n        grouped_series.push([null, frame_ts]);\n        frame_ts += ms_interval;\n      }\n      frame_values = [point[POINT_VALUE]];\n    }\n  }\n\n  frame_value = groupByCallback(frame_values);\n  grouped_series.push([frame_value, frame_ts]);\n\n  return grouped_series;\n}\n\n/**\n * Summarize set of time series into one.\n * @param {datapoints[]} timeseries array of time series\n */\nfunction sumSeries(timeseries) {\n\n  // Calculate new points for interpolation\n  var new_timestamps = _.uniq(_.map(_.flatten(timeseries, true), function (point) {\n    return point[1];\n  }));\n  new_timestamps = _.sortBy(new_timestamps);\n\n  var interpolated_timeseries = _.map(timeseries, function (series) {\n    series = fillZeroes(series, new_timestamps);\n    var timestamps = _.map(series, function (point) {\n      return point[1];\n    });\n    var new_points = _.map(_.difference(new_timestamps, timestamps), function (timestamp) {\n      return [null, timestamp];\n    });\n    var new_series = series.concat(new_points);\n    return sortByTime(new_series);\n  });\n\n  _.each(interpolated_timeseries, interpolateSeries);\n\n  var new_timeseries = [];\n  var sum;\n  for (var i = new_timestamps.length - 1; i >= 0; i--) {\n    sum = 0;\n    for (var j = interpolated_timeseries.length - 1; j >= 0; j--) {\n      sum += interpolated_timeseries[j][i][0];\n    }\n    new_timeseries.push([sum, new_timestamps[i]]);\n  }\n\n  return sortByTime(new_timeseries);\n}\n\nfunction scale(datapoints, factor) {\n  return _.map(datapoints, point => {\n    return [\n      point[0] * factor,\n      point[1]\n    ];\n  });\n}\n\nfunction scale_perf(datapoints, factor) {\n  for (let i = 0; i < datapoints.length; i++) {\n    datapoints[i] = [\n      datapoints[i][POINT_VALUE] * factor,\n      datapoints[i][POINT_TIMESTAMP]\n    ];\n  }\n\n  return datapoints;\n}\n\nfunction offset(datapoints, delta) {\n  for (let i = 0; i < datapoints.length; i++) {\n    datapoints[i] = [\n      datapoints[i][POINT_VALUE] + delta,\n      datapoints[i][POINT_TIMESTAMP]\n    ];\n  }\n\n  return datapoints;\n}\n\n/**\n * Simple delta. Calculate value delta between points.\n * @param {*} datapoints\n */\nfunction delta(datapoints) {\n  let newSeries = [];\n  let deltaValue;\n  for (var i = 1; i < datapoints.length; i++) {\n    deltaValue = datapoints[i][0] - datapoints[i - 1][0];\n    newSeries.push([deltaValue, datapoints[i][1]]);\n  }\n  return newSeries;\n}\n\n/**\n * Calculates rate per second. Resistant to counter reset.\n * @param {*} datapoints\n */\nfunction rate(datapoints) {\n  let newSeries = [];\n  let point, point_prev;\n  let valueDelta = 0;\n  let timeDelta = 0;\n  for (let i = 1; i < datapoints.length; i++) {\n    point = datapoints[i];\n    point_prev = datapoints[i - 1];\n\n    // Convert ms to seconds\n    timeDelta = (point[POINT_TIMESTAMP] - point_prev[POINT_TIMESTAMP]) / 1000;\n\n    // Handle counter reset - use previous value\n    if (point[POINT_VALUE] >= point_prev[POINT_VALUE]) {\n      valueDelta = (point[POINT_VALUE] - point_prev[POINT_VALUE]) / timeDelta;\n    }\n\n    newSeries.push([valueDelta, point[POINT_TIMESTAMP]]);\n  }\n  return newSeries;\n}\n\nfunction simpleMovingAverage(datapoints, n) {\n  let sma = [];\n  let w_sum;\n  let w_avg = null;\n  let w_count = 0;\n\n  // Initial window\n  for (let j = n; j > 0; j--) {\n    if (datapoints[n - j][POINT_VALUE] !== null) {\n      w_avg += datapoints[n - j][POINT_VALUE];\n      w_count++;\n    }\n  }\n  if (w_count > 0) {\n    w_avg = w_avg / w_count;\n  } else {\n    w_avg = null;\n  }\n  sma.push([w_avg, datapoints[n - 1][POINT_TIMESTAMP]]);\n\n  for (let i = n; i < datapoints.length; i++) {\n    // Insert next value\n    if (datapoints[i][POINT_VALUE] !== null) {\n      w_sum = w_avg * w_count;\n      w_avg = (w_sum + datapoints[i][POINT_VALUE]) / (w_count + 1);\n      w_count++;\n    }\n    // Remove left side point\n    if (datapoints[i - n][POINT_VALUE] !== null) {\n      w_sum = w_avg * w_count;\n      if (w_count > 1) {\n        w_avg = (w_sum - datapoints[i - n][POINT_VALUE]) / (w_count - 1);\n        w_count--;\n      } else {\n        w_avg = null;\n        w_count = 0;\n      }\n    }\n    sma.push([w_avg, datapoints[i][POINT_TIMESTAMP]]);\n  }\n  return sma;\n}\n\nfunction expMovingAverage(datapoints, n) {\n  let ema = [datapoints[0]];\n  let ema_prev = datapoints[0][POINT_VALUE];\n  let ema_cur;\n  let a;\n\n  if (n > 1) {\n    // Calculate a from window size\n    a = 2 / (n + 1);\n\n    // Initial window, use simple moving average\n    let w_avg = null;\n    let w_count = 0;\n    for (let j = n; j > 0; j--) {\n      if (datapoints[n - j][POINT_VALUE] !== null) {\n        w_avg += datapoints[n - j][POINT_VALUE];\n        w_count++;\n      }\n    }\n    if (w_count > 0) {\n      w_avg = w_avg / w_count;\n      // Actually, we should set timestamp from datapoints[n-1] and start calculation of EMA from n.\n      // But in order to start EMA from first point (not from Nth) we should expand time range and request N additional\n      // points outside left side of range. We can't do that, so this trick is used for pretty view of first N points.\n      // We calculate AVG for first N points, but then start from 2nd point, not from Nth. In general, it means we\n      // assume that previous N values (0-N, 0-(N-1), ..., 0-1) have the same average value as a first N values.\n      ema = [[w_avg, datapoints[0][POINT_TIMESTAMP]]];\n      ema_prev = w_avg;\n      n = 1;\n    }\n  } else {\n    // Use predefined a and start from 1st point (use it as initial EMA value)\n    a = n;\n    n = 1;\n  }\n\n  for (let i = n; i < datapoints.length; i++) {\n    if (datapoints[i][POINT_VALUE] !== null) {\n      ema_cur = a * datapoints[i][POINT_VALUE] + (1 - a) * ema_prev;\n      ema_prev = ema_cur;\n      ema.push([ema_cur, datapoints[i][POINT_TIMESTAMP]]);\n    } else {\n      ema.push([null, datapoints[i][POINT_TIMESTAMP]]);\n    }\n  }\n  return ema;\n}\n\nfunction PERCENTILE(n, values) {\n  var sorted = _.sortBy(values);\n  return sorted[Math.floor(sorted.length * n / 100)];\n}\n\nfunction COUNT(values) {\n  return values.length;\n}\n\nfunction SUM(values) {\n  var sum = null;\n  for (let i = 0; i < values.length; i++) {\n    if (values[i] !== null) {\n      sum += values[i];\n    }\n  }\n  return sum;\n}\n\nfunction AVERAGE(values) {\n  let values_non_null = getNonNullValues(values);\n  if (values_non_null.length === 0) {\n    return null;\n  }\n  return SUM(values_non_null) / values_non_null.length;\n}\n\nfunction getNonNullValues(values) {\n  let values_non_null = [];\n  for (let i = 0; i < values.length; i++) {\n    if (values[i] !== null) {\n      values_non_null.push(values[i]);\n    }\n  }\n  return values_non_null;\n}\n\nfunction MIN(values) {\n  return _.min(values);\n}\n\nfunction MAX(values) {\n  return _.max(values);\n}\n\nfunction MEDIAN(values) {\n  var sorted = _.sortBy(values);\n  return sorted[Math.floor(sorted.length / 2)];\n}\n\n///////////////////////\n// Utility functions //\n///////////////////////\n\n/**\n * For given point calculate corresponding time frame.\n *\n * |__*_|_*__|___*| -> |*___|*___|*___|\n *\n * @param {*} timestamp\n * @param {*} ms_interval\n */\nfunction getPointTimeFrame(timestamp, ms_interval) {\n  return Math.floor(timestamp / ms_interval) * ms_interval;\n}\n\nfunction sortByTime(series) {\n  return _.sortBy(series, function (point) {\n    return point[1];\n  });\n}\n\n/**\n * Fill empty front and end of series by zeroes.\n *\n * |   ***   |    |   ***   |\n * |___   ___| -> |***   ***|\n * @param {*} series\n * @param {*} timestamps\n */\nfunction fillZeroes(series, timestamps) {\n  let prepend = [];\n  let append = [];\n  let new_point;\n  for (let i = 0; i < timestamps.length; i++) {\n    if (timestamps[i] < series[0][POINT_TIMESTAMP]) {\n      new_point = [0, timestamps[i]];\n      prepend.push(new_point);\n    } else if (timestamps[i] > series[series.length - 1][POINT_TIMESTAMP]) {\n      new_point = [0, timestamps[i]];\n      append.push(new_point);\n    }\n  }\n  return _.concat(_.concat(prepend, series), append);\n}\n\n/**\n * Interpolate series with gaps\n */\nfunction interpolateSeries(series) {\n  var left, right;\n\n  // Interpolate series\n  for (var i = series.length - 1; i >= 0; i--) {\n    if (!series[i][0]) {\n      left = findNearestLeft(series, i);\n      right = findNearestRight(series, i);\n      if (!left) {\n        left = right;\n      }\n      if (!right) {\n        right = left;\n      }\n      series[i][0] = linearInterpolation(series[i][1], left, right);\n    }\n  }\n  return series;\n}\n\nfunction linearInterpolation(timestamp, left, right) {\n  if (left[1] === right[1]) {\n    return (left[0] + right[0]) / 2;\n  } else {\n    return (left[0] + (right[0] - left[0]) / (right[1] - left[1]) * (timestamp - left[1]));\n  }\n}\n\nfunction findNearestRight(series, pointIndex) {\n  for (var i = pointIndex; i < series.length; i++) {\n    if (series[i][0] !== null) {\n      return series[i];\n    }\n  }\n  return null;\n}\n\nfunction findNearestLeft(series, pointIndex) {\n  for (var i = pointIndex; i > 0; i--) {\n    if (series[i][0] !== null) {\n      return series[i];\n    }\n  }\n  return null;\n}\n\nfunction flattenDatapoints(datapoints) {\n  const depth = utils.getArrayDepth(datapoints);\n  if (depth <= 2) {\n    // Don't process if datapoints already flattened\n    return datapoints;\n  }\n  return _.flatten(datapoints);\n}\n\n////////////\n// Export //\n////////////\n\nconst exportedFunctions = {\n  downsample,\n  groupBy,\n  groupBy_perf,\n  sumSeries,\n  scale,\n  offset,\n  scale_perf,\n  delta,\n  rate,\n  simpleMovingAverage,\n  expMovingAverage,\n  SUM,\n  COUNT,\n  AVERAGE,\n  MIN,\n  MAX,\n  MEDIAN,\n  PERCENTILE,\n  sortByTime,\n  flattenDatapoints,\n};\n\nexport default exportedFunctions;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__40__;","import _ from 'lodash';\nimport * as utils from '../utils';\nimport responseHandler from '../responseHandler';\nimport { CachingProxy } from './proxy/cachingProxy';\nimport { ZabbixNotImplemented } from './connectors/dbConnector';\nimport { DBConnector } from './connectors/dbConnector';\nimport { ZabbixAPIConnector } from './connectors/zabbix_api/zabbixAPIConnector';\nimport { SQLConnector } from './connectors/sql/sqlConnector';\nimport { InfluxDBConnector } from './connectors/influxdb/influxdbConnector';\n\nconst REQUESTS_TO_PROXYFY = [\n  'getHistory', 'getTrend', 'getGroups', 'getHosts', 'getApps', 'getItems', 'getMacros', 'getItemsByIDs',\n  'getEvents', 'getAlerts', 'getHostAlerts', 'getAcknowledges', 'getITService', 'getSLA', 'getVersion', 'getProxies',\n  'getEventAlerts', 'getExtendedEventData'\n];\n\nconst REQUESTS_TO_CACHE = [\n  'getGroups', 'getHosts', 'getApps', 'getItems', 'getMacros', 'getItemsByIDs', 'getITService', 'getProxies'\n];\n\nconst REQUESTS_TO_BIND = [\n  'getHistory', 'getTrend', 'getMacros', 'getItemsByIDs', 'getEvents', 'getAlerts', 'getHostAlerts',\n  'getAcknowledges', 'getITService', 'getVersion', 'login', 'acknowledgeEvent', 'getProxies', 'getEventAlerts',\n  'getExtendedEventData'\n];\n\nexport class Zabbix {\n  constructor(options, datasourceSrv, backendSrv) {\n    let {\n      url,\n      username,\n      password,\n      basicAuth,\n      withCredentials,\n      zabbixVersion,\n      cacheTTL,\n      enableDirectDBConnection,\n      dbConnectionDatasourceId,\n      dbConnectionDatasourceName,\n      dbConnectionRetentionPolicy,\n    } = options;\n\n    this.enableDirectDBConnection = enableDirectDBConnection;\n\n    // Initialize caching proxy for requests\n    let cacheOptions = {\n      enabled: true,\n      ttl: cacheTTL\n    };\n    this.cachingProxy = new CachingProxy(cacheOptions);\n\n    this.zabbixAPI = new ZabbixAPIConnector(url, username, password, zabbixVersion, basicAuth, withCredentials, backendSrv);\n\n    this.proxyfyRequests();\n    this.cacheRequests();\n    this.bindRequests();\n\n    if (enableDirectDBConnection) {\n      const connectorOptions = { dbConnectionRetentionPolicy };\n      this.initDBConnector(dbConnectionDatasourceId, dbConnectionDatasourceName, datasourceSrv, connectorOptions)\n      .then(() => {\n        this.getHistoryDB = this.cachingProxy.proxyfyWithCache(this.dbConnector.getHistory, 'getHistory', this.dbConnector);\n        this.getTrendsDB = this.cachingProxy.proxyfyWithCache(this.dbConnector.getTrends, 'getTrends', this.dbConnector);\n      });\n    }\n  }\n\n  initDBConnector(datasourceId, datasourceName, datasourceSrv, options) {\n    return DBConnector.loadDatasource(datasourceId, datasourceName, datasourceSrv)\n    .then(ds => {\n      let connectorOptions = { datasourceId, datasourceName };\n      if (ds.type === 'influxdb') {\n        connectorOptions.retentionPolicy = options.dbConnectionRetentionPolicy;\n        this.dbConnector = new InfluxDBConnector(connectorOptions, datasourceSrv);\n      } else {\n        this.dbConnector = new SQLConnector(connectorOptions, datasourceSrv);\n      }\n      return this.dbConnector;\n    });\n  }\n\n  proxyfyRequests() {\n    for (let request of REQUESTS_TO_PROXYFY) {\n      this.zabbixAPI[request] = this.cachingProxy.proxyfy(this.zabbixAPI[request], request, this.zabbixAPI);\n    }\n  }\n\n  cacheRequests() {\n    for (let request of REQUESTS_TO_CACHE) {\n      this.zabbixAPI[request] = this.cachingProxy.cacheRequest(this.zabbixAPI[request], request, this.zabbixAPI);\n    }\n  }\n\n  bindRequests() {\n    for (let request of REQUESTS_TO_BIND) {\n      this[request] = this.zabbixAPI[request].bind(this.zabbixAPI);\n    }\n  }\n\n  /**\n   * Perform test query for Zabbix API and external history DB.\n   * @return {object} test result object:\n   * ```\n    {\n      zabbixVersion,\n      dbConnectorStatus: {\n        dsType,\n        dsName\n      }\n    }\n   ```\n   */\n  testDataSource() {\n    let zabbixVersion;\n    let dbConnectorStatus;\n    return this.getVersion()\n    .then(version => {\n      zabbixVersion = version;\n      return this.login();\n    })\n    .then(() => {\n      if (this.enableDirectDBConnection) {\n        return this.dbConnector.testDataSource();\n      } else {\n        return Promise.resolve();\n      }\n    })\n    .catch(error => {\n      if (error instanceof ZabbixNotImplemented) {\n        return Promise.resolve();\n      }\n      return Promise.reject(error);\n    })\n    .then(testResult => {\n      if (testResult) {\n        dbConnectorStatus = {\n          dsType: this.dbConnector.datasourceTypeName,\n          dsName: this.dbConnector.datasourceName\n        };\n      }\n      return { zabbixVersion, dbConnectorStatus };\n    });\n  }\n\n  getItemsFromTarget(target, options) {\n    let parts = ['group', 'host', 'application', 'item'];\n    let filters = _.map(parts, p => target[p].filter);\n    return this.getItems(...filters, options);\n  }\n\n  getHostsFromTarget(target) {\n    let parts = ['group', 'host', 'application'];\n    let filters = _.map(parts, p => target[p].filter);\n    return Promise.all([\n      this.getHosts(...filters),\n      this.getApps(...filters),\n    ]).then((results) => {\n      let [hosts, apps] = results;\n      if (apps.appFilterEmpty) {\n        apps = [];\n      }\n      return [hosts, apps];\n    });\n  }\n\n  getAllGroups() {\n    return this.zabbixAPI.getGroups();\n  }\n\n  getGroups(groupFilter) {\n    return this.getAllGroups()\n    .then(groups => findByFilter(groups, groupFilter));\n  }\n\n  /**\n   * Get list of host belonging to given groups.\n   */\n  getAllHosts(groupFilter) {\n    return this.getGroups(groupFilter)\n    .then(groups => {\n      let groupids = _.map(groups, 'groupid');\n      return this.zabbixAPI.getHosts(groupids);\n    });\n  }\n\n  getHosts(groupFilter, hostFilter) {\n    return this.getAllHosts(groupFilter)\n    .then(hosts => findByFilter(hosts, hostFilter));\n  }\n\n  /**\n   * Get list of applications belonging to given groups and hosts.\n   */\n  getAllApps(groupFilter, hostFilter) {\n    return this.getHosts(groupFilter, hostFilter)\n    .then(hosts => {\n      let hostids = _.map(hosts, 'hostid');\n      return this.zabbixAPI.getApps(hostids);\n    });\n  }\n\n  getApps(groupFilter, hostFilter, appFilter) {\n    return this.getHosts(groupFilter, hostFilter)\n    .then(hosts => {\n      let hostids = _.map(hosts, 'hostid');\n      if (appFilter) {\n        return this.zabbixAPI.getApps(hostids)\n        .then(apps => filterByQuery(apps, appFilter));\n      } else {\n        return {\n          appFilterEmpty: true,\n          hostids: hostids\n        };\n      }\n    });\n  }\n\n  getAllItems(groupFilter, hostFilter, appFilter, options = {}) {\n    return this.getApps(groupFilter, hostFilter, appFilter)\n    .then(apps => {\n      if (apps.appFilterEmpty) {\n        return this.zabbixAPI.getItems(apps.hostids, undefined, options.itemtype);\n      } else {\n        let appids = _.map(apps, 'applicationid');\n        return this.zabbixAPI.getItems(undefined, appids, options.itemtype);\n      }\n    })\n    .then(items => {\n      if (!options.showDisabledItems) {\n        items = _.filter(items, {'status': '0'});\n      }\n\n      return items;\n    })\n    .then(this.expandUserMacro.bind(this));\n  }\n\n  expandUserMacro(items) {\n    let hostids = getHostIds(items);\n    return this.getMacros(hostids)\n    .then(macros => {\n      _.forEach(items, item => {\n        if (utils.containsMacro(item.name)) {\n          item.name = utils.replaceMacro(item, macros);\n        }\n      });\n      return items;\n    });\n  }\n\n  getItems(groupFilter, hostFilter, appFilter, itemFilter, options = {}) {\n    return this.getAllItems(groupFilter, hostFilter, appFilter, options)\n    .then(items => filterByQuery(items, itemFilter));\n  }\n\n  getITServices(itServiceFilter) {\n    return this.zabbixAPI.getITService()\n    .then(itServices => findByFilter(itServices, itServiceFilter));\n  }\n\n  /**\n   * Build query - convert target filters to array of Zabbix items\n   */\n  getTriggers(groupFilter, hostFilter, appFilter, options, proxyFilter) {\n    let promises = [\n      this.getGroups(groupFilter),\n      this.getHosts(groupFilter, hostFilter),\n      this.getApps(groupFilter, hostFilter, appFilter)\n    ];\n\n    return Promise.all(promises)\n    .then(results => {\n      let [filteredGroups, filteredHosts, filteredApps] = results;\n      let query = {};\n\n      if (appFilter) {\n        query.applicationids = _.flatten(_.map(filteredApps, 'applicationid'));\n      }\n      if (hostFilter) {\n        query.hostids = _.map(filteredHosts, 'hostid');\n      }\n      if (groupFilter) {\n        query.groupids = _.map(filteredGroups, 'groupid');\n      }\n\n      return query;\n    })\n    .then(query => this.zabbixAPI.getTriggers(query.groupids, query.hostids, query.applicationids, options))\n    .then(triggers => this.filterTriggersByProxy(triggers, proxyFilter));\n  }\n\n  filterTriggersByProxy(triggers, proxyFilter) {\n    return this.getFilteredProxies(proxyFilter)\n    .then(proxies => {\n      if (proxyFilter && proxyFilter !== '/.*/' && triggers) {\n        const proxy_ids = proxies.map(proxy => proxy.proxyid);\n        triggers = triggers.filter(trigger => {\n          let filtered = false;\n          for(let i = 0; i < trigger.hosts.length; i++) {\n            const host = trigger.hosts[i];\n            if (proxy_ids.includes(host.proxy_hostid)) {\n              filtered = true;\n            }\n          }\n          return filtered;\n        });\n      }\n      return triggers;\n    });\n  }\n\n  getFilteredProxies(proxyFilter) {\n    return this.zabbixAPI.getProxies()\n    .then(proxies => {\n      proxies.forEach(proxy => proxy.name = proxy.host);\n      return findByFilter(proxies, proxyFilter);\n    });\n  }\n\n  getHistoryTS(items, timeRange, options) {\n    let [timeFrom, timeTo] = timeRange;\n    if (this.enableDirectDBConnection) {\n      return this.getHistoryDB(items, timeFrom, timeTo, options)\n      .then(history => this.dbConnector.handleGrafanaTSResponse(history, items));\n    } else {\n      return this.zabbixAPI.getHistory(items, timeFrom, timeTo)\n      .then(history => responseHandler.handleHistory(history, items));\n    }\n  }\n\n  getTrends(items, timeRange, options) {\n    let [timeFrom, timeTo] = timeRange;\n    if (this.enableDirectDBConnection) {\n      return this.getTrendsDB(items, timeFrom, timeTo, options)\n      .then(history => this.dbConnector.handleGrafanaTSResponse(history, items));\n    } else {\n      let valueType = options.consolidateBy || options.valueType;\n      return this.zabbixAPI.getTrend(items, timeFrom, timeTo)\n      .then(history => responseHandler.handleTrends(history, items, valueType))\n      .then(responseHandler.sortTimeseries); // Sort trend data, issue #202\n    }\n  }\n\n  getHistoryText(items, timeRange, target) {\n    let [timeFrom, timeTo] = timeRange;\n    if (items.length) {\n      return this.zabbixAPI.getHistory(items, timeFrom, timeTo)\n      .then(history => {\n        if (target.resultFormat === 'table') {\n          return responseHandler.handleHistoryAsTable(history, items, target);\n        } else {\n          return responseHandler.handleText(history, items, target);\n        }\n      });\n    } else {\n      return Promise.resolve([]);\n    }\n  }\n\n  getSLA(itservices, timeRange, target, options) {\n    let itServices = itservices;\n    if (options.isOldVersion) {\n      itServices = _.filter(itServices, {'serviceid': target.itservice.serviceid});\n    }\n    let itServiceIds = _.map(itServices, 'serviceid');\n    return this.zabbixAPI.getSLA(itServiceIds, timeRange)\n    .then(slaResponse => {\n      return _.map(itServiceIds, serviceid => {\n        let itservice = _.find(itServices, {'serviceid': serviceid});\n        return responseHandler.handleSLAResponse(itservice, target.slaProperty, slaResponse);\n      });\n    });\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Find group, host, app or item by given name.\n * @param  list list of groups, apps or other\n * @param  name visible name\n * @return      array with finded element or empty array\n */\nfunction findByName(list, name) {\n  var finded = _.find(list, {'name': name});\n  if (finded) {\n    return [finded];\n  } else {\n    return [];\n  }\n}\n\n/**\n * Different hosts can contains applications and items with same name.\n * For this reason use _.filter, which return all elements instead _.find,\n * which return only first finded.\n * @param  {[type]} list list of elements\n * @param  {[type]} name app name\n * @return {[type]}      array with finded element or empty array\n */\nfunction filterByName(list, name) {\n  var finded = _.filter(list, {'name': name});\n  if (finded) {\n    return finded;\n  } else {\n    return [];\n  }\n}\n\nfunction filterByRegex(list, regex) {\n  var filterPattern = utils.buildRegex(regex);\n  return _.filter(list, function (zbx_obj) {\n    return filterPattern.test(zbx_obj.name);\n  });\n}\n\nfunction findByFilter(list, filter) {\n  if (utils.isRegex(filter)) {\n    return filterByRegex(list, filter);\n  } else {\n    return findByName(list, filter);\n  }\n}\n\nfunction filterByQuery(list, filter) {\n  if (utils.isRegex(filter)) {\n    return filterByRegex(list, filter);\n  } else {\n    return filterByName(list, filter);\n  }\n}\n\nfunction getHostIds(items) {\n  let hostIds = _.map(items, item => {\n    return _.map(item.hosts, 'hostid');\n  });\n  return _.uniq(_.flatten(hostIds));\n}\n","/**\n * This module allows to deduplicate function calls with the same params and\n * cache result of function call.\n */\n\nexport class CachingProxy {\n\n  constructor(cacheOptions) {\n    this.cacheEnabled = cacheOptions.enabled;\n    this.ttl          = cacheOptions.ttl || 600000; // 10 minutes by default\n\n    // Internal objects for data storing\n    this.cache = {};\n    this.promises = {};\n  }\n\n  /**\n   * Check that result is present in the cache and is up to date or send request otherwise.\n   */\n  cacheRequest(func, funcName, funcScope) {\n    return cacheRequest(func, funcName, funcScope, this);\n  }\n\n  /**\n   * Wrap request to prevent multiple calls with same params when request is waiting for response.\n   */\n  proxyfy(func, funcName, funcScope) {\n    if (!this.promises[funcName]) {\n      this.promises[funcName] = {};\n    }\n    const promiseKeeper = this.promises[funcName];\n    return callOnce(func, promiseKeeper, funcScope);\n  }\n\n  proxyfyWithCache(func, funcName, funcScope) {\n    let proxyfied = this.proxyfy(func, funcName, funcScope);\n    return this.cacheRequest(proxyfied, funcName, funcScope);\n  }\n\n  _isExpired(cacheObject) {\n    if (cacheObject) {\n      let object_age = Date.now() - cacheObject.timestamp;\n      return !(cacheObject.timestamp && object_age < this.ttl);\n    } else {\n      return true;\n    }\n  }\n}\n\n/**\n * Wrap request to prevent multiple calls\n * with same params when waiting for result.\n */\nfunction callOnce(func, promiseKeeper, funcScope) {\n  return function() {\n    var hash = getRequestHash(arguments);\n    if (!promiseKeeper[hash]) {\n      promiseKeeper[hash] = Promise.resolve(\n        func.apply(funcScope, arguments)\n        .then(result => {\n          promiseKeeper[hash] = null;\n          return result;\n        })\n      );\n    }\n    return promiseKeeper[hash];\n  };\n}\n\nfunction cacheRequest(func, funcName, funcScope, self) {\n  return function() {\n    if (!self.cache[funcName]) {\n      self.cache[funcName] = {};\n    }\n\n    let cacheObject = self.cache[funcName];\n    let hash = getRequestHash(arguments);\n    if (self.cacheEnabled && !self._isExpired(cacheObject[hash])) {\n      return Promise.resolve(cacheObject[hash].value);\n    } else {\n      return func.apply(funcScope, arguments)\n      .then(result => {\n        cacheObject[hash] = {\n          value: result,\n          timestamp: Date.now()\n        };\n        return result;\n      });\n    }\n  };\n}\n\nfunction getRequestHash(args) {\n  const argsJson = JSON.stringify(args);\n  return argsJson.getHash();\n}\n\nString.prototype.getHash = function() {\n  var hash = 0, i, chr, len;\n  if (this.length !== 0) {\n    for (i = 0, len = this.length; i < len; i++) {\n      chr   = this.charCodeAt(i);\n      hash  = ((hash << 5) - hash) + chr;\n      hash |= 0; // Convert to 32bit integer\n    }\n  }\n  return hash;\n};\n","import _ from 'lodash';\nimport * as utils from '../../../utils';\nimport { ZabbixAPICore } from './zabbixAPICore';\nimport { ZBX_ACK_ACTION_NONE, ZBX_ACK_ACTION_ACK, ZBX_ACK_ACTION_ADD_MESSAGE } from '../../../constants';\n\n/**\n * Zabbix API Wrapper.\n * Creates Zabbix API instance with given parameters (url, credentials and other).\n * Wraps API calls and provides high-level methods.\n */\nexport class ZabbixAPIConnector {\n  constructor(api_url, username, password, version, basicAuth, withCredentials, backendSrv) {\n    this.url              = api_url;\n    this.username         = username;\n    this.password         = password;\n    this.auth             = '';\n    this.version          = version;\n\n    this.requestOptions = {\n      basicAuth: basicAuth,\n      withCredentials: withCredentials\n    };\n\n    this.loginPromise = null;\n    this.loginErrorCount = 0;\n    this.maxLoginAttempts = 3;\n\n    this.zabbixAPICore = new ZabbixAPICore(backendSrv);\n\n    this.getTrend = this.getTrend_ZBXNEXT1193;\n    //getTrend = getTrend_30;\n  }\n\n  //////////////////////////\n  // Core method wrappers //\n  //////////////////////////\n\n  request(method, params) {\n    return this.zabbixAPICore.request(this.url, method, params, this.requestOptions, this.auth)\n    .catch(error => {\n      if (isNotAuthorized(error.data)) {\n        // Handle auth errors\n        this.loginErrorCount++;\n        if (this.loginErrorCount > this.maxLoginAttempts) {\n          this.loginErrorCount = 0;\n          return null;\n        } else {\n          return this.loginOnce()\n          .then(() => this.request(method, params));\n        }\n      } else {\n        return Promise.reject(error);\n      }\n    });\n  }\n\n  /**\n   * When API unauthenticated or auth token expired each request produce login()\n   * call. But auth token is common to all requests. This function wraps login() method\n   * and call it once. If login() already called just wait for it (return its promise).\n   * @return login promise\n   */\n  loginOnce() {\n    if (!this.loginPromise) {\n      this.loginPromise = Promise.resolve(\n        this.login().then(auth => {\n          this.auth = auth;\n          this.loginPromise = null;\n          return auth;\n        })\n      );\n    }\n    return this.loginPromise;\n  }\n\n  /**\n   * Get authentication token.\n   */\n  login() {\n    return this.zabbixAPICore.login(this.url, this.username, this.password, this.requestOptions);\n  }\n\n  /**\n   * Get Zabbix API version\n   */\n  getVersion() {\n    return this.zabbixAPICore.getVersion(this.url, this.requestOptions);\n  }\n\n  ////////////////////////////////\n  // Zabbix API method wrappers //\n  ////////////////////////////////\n\n  acknowledgeEvent(eventid, message) {\n    const action = this.version >= 4 ? ZBX_ACK_ACTION_ACK + ZBX_ACK_ACTION_ADD_MESSAGE : ZBX_ACK_ACTION_NONE;\n    const params = {\n      eventids: eventid,\n      message: message,\n      action: action\n    };\n\n    return this.request('event.acknowledge', params);\n  }\n\n  getGroups() {\n    var params = {\n      output: ['name'],\n      sortfield: 'name',\n      real_hosts: true\n    };\n\n    return this.request('hostgroup.get', params);\n  }\n\n  getHosts(groupids) {\n    var params = {\n      output: ['name', 'host'],\n      sortfield: 'name'\n    };\n    if (groupids) {\n      params.groupids = groupids;\n    }\n\n    return this.request('host.get', params);\n  }\n\n  getApps(hostids) {\n    var params = {\n      output: 'extend',\n      hostids: hostids\n    };\n\n    return this.request('application.get', params);\n  }\n\n  /**\n   * Get Zabbix items\n   * @param  {[type]} hostids  host ids\n   * @param  {[type]} appids   application ids\n   * @param  {String} itemtype 'num' or 'text'\n   * @return {[type]}          array of items\n   */\n  getItems(hostids, appids, itemtype) {\n    var params = {\n      output: [\n        'name', 'key_',\n        'value_type',\n        'hostid',\n        'status',\n        'state'\n      ],\n      sortfield: 'name',\n      webitems: true,\n      filter: {},\n      selectHosts: ['hostid', 'name']\n    };\n    if (hostids) {\n      params.hostids = hostids;\n    }\n    if (appids) {\n      params.applicationids = appids;\n    }\n    if (itemtype === 'num') {\n      // Return only numeric metrics\n      params.filter.value_type = [0, 3];\n    }\n    if (itemtype === 'text') {\n      // Return only text metrics\n      params.filter.value_type = [1, 2, 4];\n    }\n\n    return this.request('item.get', params)\n    .then(utils.expandItems);\n  }\n\n  getItemsByIDs(itemids) {\n    var params = {\n      itemids: itemids,\n      output: [\n        'name', 'key_',\n        'value_type',\n        'hostid',\n        'status',\n        'state'\n      ],\n      webitems: true,\n      selectHosts: ['hostid', 'name']\n    };\n\n    return this.request('item.get', params)\n    .then(utils.expandItems);\n  }\n\n  getMacros(hostids) {\n    var params = {\n      output: 'extend',\n      hostids: hostids\n    };\n\n    return this.request('usermacro.get', params);\n  }\n\n  getGlobalMacros() {\n    var params = {\n      output: 'extend',\n      globalmacro: true\n    };\n\n    return this.request('usermacro.get', params);\n  }\n\n  getLastValue(itemid) {\n    var params = {\n      output: ['lastvalue'],\n      itemids: itemid\n    };\n    return this.request('item.get', params)\n    .then(items => items.length ? items[0].lastvalue : null);\n  }\n\n  /**\n   * Perform history query from Zabbix API\n   *\n   * @param  {Array}  items       Array of Zabbix item objects\n   * @param  {Number} timeFrom   Time in seconds\n   * @param  {Number} timeTill   Time in seconds\n   * @return {Array}  Array of Zabbix history objects\n   */\n  getHistory(items, timeFrom, timeTill) {\n\n    // Group items by value type and perform request for each value type\n    let grouped_items = _.groupBy(items, 'value_type');\n    let promises = _.map(grouped_items, (items, value_type) => {\n      let itemids = _.map(items, 'itemid');\n      let params = {\n        output: 'extend',\n        history: value_type,\n        itemids: itemids,\n        sortfield: 'clock',\n        sortorder: 'ASC',\n        time_from: timeFrom\n      };\n\n      // Relative queries (e.g. last hour) don't include an end time\n      if (timeTill) {\n        params.time_till = timeTill;\n      }\n\n      return this.request('history.get', params);\n    });\n\n    return Promise.all(promises).then(_.flatten);\n  }\n\n  /**\n   * Perform trends query from Zabbix API\n   * Use trends api extension from ZBXNEXT-1193 patch.\n   *\n   * @param  {Array}  items       Array of Zabbix item objects\n   * @param  {Number} time_from   Time in seconds\n   * @param  {Number} time_till   Time in seconds\n   * @return {Array}  Array of Zabbix trend objects\n   */\n  getTrend_ZBXNEXT1193(items, timeFrom, timeTill) {\n\n    // Group items by value type and perform request for each value type\n    let grouped_items = _.groupBy(items, 'value_type');\n    let promises = _.map(grouped_items, (items, value_type) => {\n      let itemids = _.map(items, 'itemid');\n      let params = {\n        output: 'extend',\n        trend: value_type,\n        itemids: itemids,\n        sortfield: 'clock',\n        sortorder: 'ASC',\n        time_from: timeFrom\n      };\n\n      // Relative queries (e.g. last hour) don't include an end time\n      if (timeTill) {\n        params.time_till = timeTill;\n      }\n\n      return this.request('trend.get', params);\n    });\n\n    return Promise.all(promises).then(_.flatten);\n  }\n\n  getTrend_30(items, time_from, time_till, value_type) {\n    var self = this;\n    var itemids = _.map(items, 'itemid');\n\n    var params = {\n      output: [\"itemid\",\n        \"clock\",\n        value_type\n      ],\n      itemids: itemids,\n      time_from: time_from\n    };\n\n    // Relative queries (e.g. last hour) don't include an end time\n    if (time_till) {\n      params.time_till = time_till;\n    }\n\n    return self.request('trend.get', params);\n  }\n\n  getITService(serviceids) {\n    var params = {\n      output: 'extend',\n      serviceids: serviceids\n    };\n    return this.request('service.get', params);\n  }\n\n  getSLA(serviceids, timeRange) {\n    let [timeFrom, timeTo] = timeRange;\n    var params = {\n      serviceids: serviceids,\n      intervals: [{\n        from: timeFrom,\n        to: timeTo\n      }]\n    };\n    return this.request('service.getsla', params);\n  }\n\n  getTriggers(groupids, hostids, applicationids, options) {\n    let {showTriggers, maintenance, timeFrom, timeTo} = options;\n\n    let params = {\n      output: 'extend',\n      groupids: groupids,\n      hostids: hostids,\n      applicationids: applicationids,\n      expandDescription: true,\n      expandData: true,\n      expandComment: true,\n      monitored: true,\n      skipDependent: true,\n      //only_true: true,\n      filter: {\n        value: 1\n      },\n      selectGroups: ['name'],\n      selectHosts: ['name', 'host', 'maintenance_status', 'proxy_hostid'],\n      selectItems: ['name', 'key_', 'lastvalue'],\n      selectLastEvent: 'extend',\n      selectTags: 'extend'\n    };\n\n    if (showTriggers) {\n      params.filter.value = showTriggers;\n    }\n\n    if (maintenance) {\n      params.maintenance = true;\n    }\n\n    if (timeFrom || timeTo) {\n      params.lastChangeSince = timeFrom;\n      params.lastChangeTill = timeTo;\n    }\n\n    return this.request('trigger.get', params);\n  }\n\n  getEvents(objectids, timeFrom, timeTo, showEvents, limit) {\n    var params = {\n      output: 'extend',\n      time_from: timeFrom,\n      time_till: timeTo,\n      objectids: objectids,\n      select_acknowledges: 'extend',\n      selectHosts: 'extend',\n      value: showEvents,\n    };\n\n    if (limit) {\n      params.limit = limit;\n      params.sortfield = 'clock';\n      params.sortorder = 'DESC';\n    }\n\n    return this.request('event.get', params);\n  }\n\n  getAcknowledges(eventids) {\n    var params = {\n      output: 'extend',\n      eventids: eventids,\n      preservekeys: true,\n      select_acknowledges: 'extend',\n      sortfield: 'clock',\n      sortorder: 'DESC'\n    };\n\n    return this.request('event.get', params)\n    .then(events => {\n      return _.filter(events, (event) => event.acknowledges.length);\n    });\n  }\n\n  getExtendedEventData(eventids) {\n    var params = {\n      output: 'extend',\n      eventids: eventids,\n      preservekeys: true,\n      select_acknowledges: 'extend',\n      selectTags: 'extend',\n      sortfield: 'clock',\n      sortorder: 'DESC'\n    };\n\n    return this.request('event.get', params);\n  }\n\n  getEventAlerts(eventids) {\n    const params = {\n      eventids: eventids,\n      output: [\n        'eventid',\n        'message',\n        'clock',\n        'error'\n      ],\n      selectUsers: true,\n    };\n\n    return this.request('alert.get', params);\n  }\n\n  getAlerts(itemids, timeFrom, timeTo) {\n    var params = {\n      output: 'extend',\n      itemids: itemids,\n      expandDescription: true,\n      expandData: true,\n      expandComment: true,\n      monitored: true,\n      skipDependent: true,\n      //only_true: true,\n      // filter: {\n      //   value: 1\n      // },\n      selectLastEvent: 'extend'\n    };\n\n    if (timeFrom || timeTo) {\n      params.lastChangeSince = timeFrom;\n      params.lastChangeTill = timeTo;\n    }\n\n    return this.request('trigger.get', params);\n  }\n\n  getHostAlerts(hostids, applicationids, options) {\n    let {minSeverity, acknowledged, count, timeFrom, timeTo} = options;\n    let params = {\n      output: 'extend',\n      hostids: hostids,\n      min_severity: minSeverity,\n      filter: { value: 1 },\n      expandDescription: true,\n      expandData: true,\n      expandComment: true,\n      monitored: true,\n      skipDependent: true,\n      selectLastEvent: 'extend',\n      selectGroups: 'extend',\n      selectHosts: ['host', 'name']\n    };\n\n    if (count && acknowledged !== 0 && acknowledged !== 1) {\n      params.countOutput = true;\n    }\n\n    if (applicationids && applicationids.length) {\n      params.applicationids = applicationids;\n    }\n\n    if (timeFrom || timeTo) {\n      params.lastChangeSince = timeFrom;\n      params.lastChangeTill = timeTo;\n    }\n\n    return this.request('trigger.get', params)\n    .then((triggers) => {\n      if (!count || acknowledged === 0 || acknowledged === 1) {\n        triggers = filterTriggersByAcknowledge(triggers, acknowledged);\n        if (count) {\n          triggers = triggers.length;\n        }\n      }\n      return triggers;\n    });\n  }\n\n  getProxies() {\n    var params = {\n      output: ['proxyid', 'host'],\n    };\n\n    return this.request('proxy.get', params);\n  }\n}\n\nfunction filterTriggersByAcknowledge(triggers, acknowledged) {\n  if (acknowledged === 0) {\n    return _.filter(triggers, (trigger) => trigger.lastEvent.acknowledged === \"0\");\n  } else if (acknowledged === 1) {\n    return _.filter(triggers, (trigger) => trigger.lastEvent.acknowledged === \"1\");\n  } else {\n    return triggers;\n  }\n}\n\nfunction isNotAuthorized(message) {\n  return (\n    message === \"Session terminated, re-login, please.\" ||\n    message === \"Not authorised.\" ||\n    message === \"Not authorized.\"\n  );\n}\n","import _ from 'lodash';\nimport { compactQuery } from '../../../utils';\nimport mysql from './mysql';\nimport postgres from './postgres';\nimport dbConnector, { DBConnector, DEFAULT_QUERY_LIMIT, HISTORY_TO_TABLE_MAP, TREND_TO_TABLE_MAP } from '../dbConnector';\n\nconst supportedDatabases = {\n  mysql: 'mysql',\n  postgres: 'postgres'\n};\n\nexport class SQLConnector extends DBConnector {\n  constructor(options, datasourceSrv) {\n    super(options, datasourceSrv);\n\n    this.limit = options.limit || DEFAULT_QUERY_LIMIT;\n    this.sqlDialect = null;\n\n    super.loadDBDataSource()\n    .then(ds => {\n      this.backendSrv = ds.backendSrv;\n      this.loadSQLDialect();\n    });\n  }\n\n  loadSQLDialect() {\n    if (this.datasourceTypeId === supportedDatabases.postgres) {\n      this.sqlDialect = postgres;\n    } else {\n      this.sqlDialect = mysql;\n    }\n  }\n\n  /**\n   * Try to invoke test query for one of Zabbix database tables.\n   */\n  testDataSource() {\n    let testQuery = this.sqlDialect.testQuery();\n    return this.invokeSQLQuery(testQuery);\n  }\n\n  getHistory(items, timeFrom, timeTill, options) {\n    let {intervalMs, consolidateBy} = options;\n    let intervalSec = Math.ceil(intervalMs / 1000);\n\n    consolidateBy = consolidateBy || 'avg';\n    let aggFunction = dbConnector.consolidateByFunc[consolidateBy];\n\n    // Group items by value type and perform request for each value type\n    let grouped_items = _.groupBy(items, 'value_type');\n    let promises = _.map(grouped_items, (items, value_type) => {\n      let itemids = _.map(items, 'itemid').join(', ');\n      let table = HISTORY_TO_TABLE_MAP[value_type];\n      let query = this.sqlDialect.historyQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction);\n\n      query = compactQuery(query);\n      return this.invokeSQLQuery(query);\n    });\n\n    return Promise.all(promises).then(results => {\n      return _.flatten(results);\n    });\n  }\n\n  getTrends(items, timeFrom, timeTill, options) {\n    let { intervalMs, consolidateBy } = options;\n    let intervalSec = Math.ceil(intervalMs / 1000);\n\n    consolidateBy = consolidateBy || 'avg';\n    let aggFunction = dbConnector.consolidateByFunc[consolidateBy];\n\n    // Group items by value type and perform request for each value type\n    let grouped_items = _.groupBy(items, 'value_type');\n    let promises = _.map(grouped_items, (items, value_type) => {\n      let itemids = _.map(items, 'itemid').join(', ');\n      let table = TREND_TO_TABLE_MAP[value_type];\n      let valueColumn = _.includes(['avg', 'min', 'max', 'sum'], consolidateBy) ? consolidateBy : 'avg';\n      valueColumn = dbConnector.consolidateByTrendColumns[valueColumn];\n      let query = this.sqlDialect.trendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn);\n\n      query = compactQuery(query);\n      return this.invokeSQLQuery(query);\n    });\n\n    return Promise.all(promises).then(results => {\n      return _.flatten(results);\n    });\n  }\n\n  invokeSQLQuery(query) {\n    let queryDef = {\n      refId: 'A',\n      format: 'time_series',\n      datasourceId: this.datasourceId,\n      rawSql: query,\n      maxDataPoints: this.limit\n    };\n\n    return this.backendSrv.datasourceRequest({\n      url: '/api/tsdb/query',\n      method: 'POST',\n      data: {\n        queries: [queryDef],\n      }\n    })\n    .then(response => {\n      let results = response.data.results;\n      if (results['A']) {\n        return results['A'].series;\n      } else {\n        return null;\n      }\n    });\n  }\n}\n","/**\n * MySQL queries\n */\n\nfunction historyQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction) {\n  let time_expression = `clock DIV ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT CAST(itemid AS CHAR) AS metric, ${time_expression} AS time_sec, ${aggFunction}(value) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY ${time_expression}, metric\n    ORDER BY time_sec ASC\n  `;\n  return query;\n}\n\nfunction trendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn) {\n  let time_expression = `clock DIV ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT CAST(itemid AS CHAR) AS metric, ${time_expression} AS time_sec, ${aggFunction}(${valueColumn}) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY ${time_expression}, metric\n    ORDER BY time_sec ASC\n  `;\n  return query;\n}\n\nconst TEST_QUERY = `SELECT CAST(itemid AS CHAR) AS metric, clock AS time_sec, value_avg AS value FROM trends_uint LIMIT 1`;\n\nfunction testQuery() {\n  return TEST_QUERY;\n}\n\nconst mysql = {\n  historyQuery,\n  trendsQuery,\n  testQuery\n};\n\nexport default mysql;\n","/**\n * Postgres queries\n */\n\nconst ITEMID_FORMAT = 'FM99999999999999999999';\n\nfunction historyQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction) {\n  let time_expression = `clock / ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT to_char(itemid, '${ITEMID_FORMAT}') AS metric, ${time_expression} AS time, ${aggFunction}(value) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY 1, 2\n    ORDER BY time ASC\n  `;\n  return query;\n}\n\nfunction trendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn) {\n  let time_expression = `clock / ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT to_char(itemid, '${ITEMID_FORMAT}') AS metric, ${time_expression} AS time, ${aggFunction}(${valueColumn}) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY 1, 2\n    ORDER BY time ASC\n  `;\n  return query;\n}\n\nconst TEST_QUERY = `\n  SELECT to_char(itemid, '${ITEMID_FORMAT}') AS metric, clock AS time, value_avg AS value\n  FROM trends_uint LIMIT 1\n`;\n\nfunction testQuery() {\n  return TEST_QUERY;\n}\n\nconst postgres = {\n  historyQuery,\n  trendsQuery,\n  testQuery\n};\n\nexport default postgres;\n","import _ from 'lodash';\nimport { compactQuery } from '../../../utils';\nimport { DBConnector, HISTORY_TO_TABLE_MAP, consolidateByTrendColumns } from '../dbConnector';\n\nconst consolidateByFunc = {\n  'avg': 'MEAN',\n  'min': 'MIN',\n  'max': 'MAX',\n  'sum': 'SUM',\n  'count': 'COUNT'\n};\n\nexport class InfluxDBConnector extends DBConnector {\n  constructor(options, datasourceSrv) {\n    super(options, datasourceSrv);\n    this.retentionPolicy = options.retentionPolicy;\n    super.loadDBDataSource().then(ds => {\n      this.influxDS = ds;\n      return ds;\n    });\n  }\n\n  /**\n   * Try to invoke test query for one of Zabbix database tables.\n   */\n  testDataSource() {\n    return this.influxDS.testDatasource();\n  }\n\n  getHistory(items, timeFrom, timeTill, options) {\n    let { intervalMs, consolidateBy, retentionPolicy } = options;\n    const intervalSec = Math.ceil(intervalMs / 1000);\n\n    const range = { timeFrom, timeTill };\n    consolidateBy = consolidateBy || 'avg';\n\n    // Group items by value type and perform request for each value type\n    const grouped_items = _.groupBy(items, 'value_type');\n    const promises = _.map(grouped_items, (items, value_type) => {\n      const itemids = _.map(items, 'itemid');\n      const table = HISTORY_TO_TABLE_MAP[value_type];\n      const query = this.buildHistoryQuery(itemids, table, range, intervalSec, consolidateBy, retentionPolicy);\n      return this.invokeInfluxDBQuery(query);\n    });\n\n    return Promise.all(promises)\n    .then(_.flatten)\n    .then(results => {\n      return handleInfluxHistoryResponse(results);\n    });\n  }\n\n  getTrends(items, timeFrom, timeTill, options) {\n    options.retentionPolicy = this.retentionPolicy;\n    return this.getHistory(items, timeFrom, timeTill, options);\n  }\n\n  buildHistoryQuery(itemids, table, range, intervalSec, aggFunction, retentionPolicy) {\n    const { timeFrom, timeTill } = range;\n    const measurement = retentionPolicy ? `\"${retentionPolicy}\".\"${table}\"` : `\"${table}\"`;\n    let value = 'value';\n    if (retentionPolicy) {\n      value = consolidateByTrendColumns[aggFunction] || 'value_avg';\n    }\n    const aggregation = consolidateByFunc[aggFunction] || aggFunction;\n    const where_clause = this.buildWhereClause(itemids);\n    const query = `SELECT ${aggregation}(\"${value}\") FROM ${measurement}\n      WHERE ${where_clause} AND \"time\" >= ${timeFrom}s AND \"time\" <= ${timeTill}s\n      GROUP BY time(${intervalSec}s), \"itemid\" fill(none)`;\n    return compactQuery(query);\n  }\n\n  buildWhereClause(itemids) {\n    const itemidsWhere = itemids.map(itemid => `\"itemid\" = '${itemid}'`).join(' OR ');\n    return `(${itemidsWhere})`;\n  }\n\n  invokeInfluxDBQuery(query) {\n    return this.influxDS._seriesQuery(query)\n    .then(data => data && data.results ? data.results : []);\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nfunction handleInfluxHistoryResponse(results) {\n  if (!results) {\n    return [];\n  }\n\n  const seriesList = [];\n  for (let i = 0; i < results.length; i++) {\n    const result = results[i];\n\n    if (result.error) {\n      const error = `InfluxDB error: ${result.error}`;\n      return Promise.reject(new Error(error));\n    }\n\n    if (!result || !result.series) {\n      continue;\n    }\n\n    const influxSeriesList = results[i].series;\n\n    for (let y = 0; y < influxSeriesList.length; y++) {\n      const influxSeries = influxSeriesList[y];\n      const datapoints = [];\n      if (influxSeries.values) {\n        for (i = 0; i < influxSeries.values.length; i++) {\n          datapoints[i] = [influxSeries.values[i][1], influxSeries.values[i][0]];\n        }\n      }\n      const timeSeries = {\n        name: influxSeries.tags.itemid,\n        points: datapoints\n      };\n      seriesList.push(timeSeries);\n    }\n  }\n\n  return seriesList;\n}\n","import { QueryCtrl } from 'grafana/app/plugins/sdk';\nimport _ from 'lodash';\nimport * as c from './constants';\nimport * as utils from './utils';\nimport * as metricFunctions from './metricFunctions';\nimport * as migrations from './migrations';\n\nexport class ZabbixQueryController extends QueryCtrl {\n\n  /** @ngInject */\n  constructor($scope, $injector, $rootScope, $sce, templateSrv) {\n    super($scope, $injector);\n    this.zabbix = this.datasource.zabbix;\n\n    // Use custom format for template variables\n    this.replaceTemplateVars = this.datasource.replaceTemplateVars;\n    this.templateSrv = templateSrv;\n\n    this.editorModes = [\n      {value: 'num',       text: 'Metrics',     mode: c.MODE_METRICS},\n      {value: 'text',      text: 'Text',        mode: c.MODE_TEXT},\n      {value: 'itservice', text: 'IT Services', mode: c.MODE_ITSERVICE},\n      {value: 'itemid',    text: 'Item ID',     mode: c.MODE_ITEMID},\n      {value: 'triggers',  text: 'Triggers',    mode: c.MODE_TRIGGERS}\n    ];\n\n    this.$scope.editorMode = {\n      METRICS: c.MODE_METRICS,\n      TEXT: c.MODE_TEXT,\n      ITSERVICE: c.MODE_ITSERVICE,\n      ITEMID: c.MODE_ITEMID,\n      TRIGGERS: c.MODE_TRIGGERS\n    };\n\n    this.slaPropertyList = [\n      {name: \"Status\", property: \"status\"},\n      {name: \"SLA\", property: \"sla\"},\n      {name: \"OK time\", property: \"okTime\"},\n      {name: \"Problem time\", property: \"problemTime\"},\n      {name: \"Down time\", property: \"downtimeTime\"}\n    ];\n\n    this.ackFilters = [\n      {text: 'all triggers', value: 2},\n      {text: 'unacknowledged', value: 0},\n      {text: 'acknowledged', value: 1},\n    ];\n\n    this.resultFormats = [{ text: 'Time series', value: 'time_series' }, { text: 'Table', value: 'table' }];\n\n    this.triggerSeverity = c.TRIGGER_SEVERITY;\n\n    // Map functions for bs-typeahead\n    this.getGroupNames = _.bind(this.getMetricNames, this, 'groupList');\n    this.getHostNames = _.bind(this.getMetricNames, this, 'hostList', true);\n    this.getApplicationNames = _.bind(this.getMetricNames, this, 'appList');\n    this.getItemNames = _.bind(this.getMetricNames, this, 'itemList');\n    this.getITServices = _.bind(this.getMetricNames, this, 'itServiceList');\n    this.getVariables = _.bind(this.getTemplateVariables, this);\n\n    // Update metric suggestion when template variable was changed\n    $rootScope.$on('template-variable-value-updated', () => this.onVariableChange());\n\n    // Update metrics when item selected from dropdown\n    $scope.$on('typeahead-updated', () => {\n      this.onTargetBlur();\n    });\n\n    this.init = function() {\n      var target = this.target;\n\n      // Migrate old targets\n      target = migrations.migrate(target);\n\n      var scopeDefaults = {\n        metric: {},\n        oldTarget: _.cloneDeep(this.target),\n        queryOptionsText: this.renderQueryOptionsText()\n      };\n      _.defaults(this, scopeDefaults);\n\n      // Load default values\n      var targetDefaults = {\n        'mode': c.MODE_METRICS,\n        'group': { 'filter': \"\" },\n        'host': { 'filter': \"\" },\n        'application': { 'filter': \"\" },\n        'item': { 'filter': \"\" },\n        'functions': [],\n        'triggers': {\n          'count': true,\n          'minSeverity': 3,\n          'acknowledged': 2\n        },\n        'options': {\n          'showDisabledItems': false,\n          'skipEmptyValues': false\n        },\n        'table': {\n          'skipEmptyValues': false\n        }\n      };\n      _.defaults(target, targetDefaults);\n\n      // Create function instances from saved JSON\n      target.functions = _.map(target.functions, function(func) {\n        return metricFunctions.createFuncInstance(func.def, func.params);\n      });\n\n      if (target.mode === c.MODE_METRICS ||\n          target.mode === c.MODE_TEXT ||\n          target.mode === c.MODE_TRIGGERS) {\n        this.initFilters();\n      }\n      else if (target.mode === c.MODE_ITSERVICE) {\n        _.defaults(target, {slaProperty: {name: \"SLA\", property: \"sla\"}});\n        this.suggestITServices();\n      }\n    };\n\n    this.init();\n    this.queryOptionsText = this.renderQueryOptionsText();\n  }\n\n  initFilters() {\n    let itemtype = _.find(this.editorModes, {'mode': this.target.mode});\n    itemtype = itemtype ? itemtype.value : null;\n    return Promise.all([\n      this.suggestGroups(),\n      this.suggestHosts(),\n      this.suggestApps(),\n      this.suggestItems(itemtype)\n    ]);\n  }\n\n  // Get list of metric names for bs-typeahead directive\n  getMetricNames(metricList, addAllValue) {\n    let metrics = _.uniq(_.map(this.metric[metricList], 'name'));\n\n    // Add template variables\n    _.forEach(this.templateSrv.variables, variable => {\n      metrics.unshift('$' + variable.name);\n    });\n\n    if (addAllValue) {\n      metrics.unshift('/.*/');\n    }\n\n    return metrics;\n  }\n\n  getTemplateVariables() {\n    return _.map(this.templateSrv.variables, variable => {\n      return '$' + variable.name;\n    });\n  }\n\n  suggestGroups() {\n    return this.zabbix.getAllGroups()\n    .then(groups => {\n      this.metric.groupList = groups;\n      return groups;\n    });\n  }\n\n  suggestHosts() {\n    let groupFilter = this.replaceTemplateVars(this.target.group.filter);\n    return this.zabbix.getAllHosts(groupFilter)\n    .then(hosts => {\n      this.metric.hostList = hosts;\n      return hosts;\n    });\n  }\n\n  suggestApps() {\n    let groupFilter = this.replaceTemplateVars(this.target.group.filter);\n    let hostFilter = this.replaceTemplateVars(this.target.host.filter);\n    return this.zabbix.getAllApps(groupFilter, hostFilter)\n    .then(apps => {\n      this.metric.appList = apps;\n      return apps;\n    });\n  }\n\n  suggestItems(itemtype = 'num') {\n    let groupFilter = this.replaceTemplateVars(this.target.group.filter);\n    let hostFilter = this.replaceTemplateVars(this.target.host.filter);\n    let appFilter = this.replaceTemplateVars(this.target.application.filter);\n    let options = {\n      itemtype: itemtype,\n      showDisabledItems: this.target.options.showDisabledItems\n    };\n\n    return this.zabbix\n    .getAllItems(groupFilter, hostFilter, appFilter, options)\n    .then(items => {\n      this.metric.itemList = items;\n      return items;\n    });\n  }\n\n  suggestITServices() {\n    return this.zabbix.getITService()\n    .then(itservices => {\n      this.metric.itServiceList = itservices;\n      return itservices;\n    });\n  }\n\n  isRegex(str) {\n    return utils.isRegex(str);\n  }\n\n  isVariable(str) {\n    return utils.isTemplateVariable(str, this.templateSrv.variables);\n  }\n\n  onTargetBlur() {\n    var newTarget = _.cloneDeep(this.target);\n    if (!_.isEqual(this.oldTarget, this.target)) {\n      this.oldTarget = newTarget;\n      this.targetChanged();\n    }\n  }\n\n  onVariableChange() {\n    if (this.isContainsVariables()) {\n      this.targetChanged();\n    }\n  }\n\n  /**\n   * Check query for template variables\n   */\n  isContainsVariables() {\n    return _.some(['group', 'host', 'application'], field => {\n      if (this.target[field] && this.target[field].filter) {\n        return utils.isTemplateVariable(this.target[field].filter, this.templateSrv.variables);\n      } else {\n        return false;\n      }\n    });\n  }\n\n  parseTarget() {\n    // Parse target\n  }\n\n  // Validate target and set validation info\n  validateTarget() {\n    // validate\n  }\n\n  targetChanged() {\n    this.initFilters();\n    this.parseTarget();\n    this.panelCtrl.refresh();\n  }\n\n  addFunction(funcDef) {\n    var newFunc = metricFunctions.createFuncInstance(funcDef);\n    newFunc.added = true;\n    this.target.functions.push(newFunc);\n\n    this.moveAliasFuncLast();\n\n    if (newFunc.params.length && newFunc.added ||\n        newFunc.def.params.length === 0) {\n      this.targetChanged();\n    }\n  }\n\n  removeFunction(func) {\n    this.target.functions = _.without(this.target.functions, func);\n    this.targetChanged();\n  }\n\n  moveAliasFuncLast() {\n    var aliasFunc = _.find(this.target.functions, function(func) {\n      return func.def.name === 'alias' ||\n        func.def.name === 'aliasByNode' ||\n        func.def.name === 'aliasByMetric';\n    });\n\n    if (aliasFunc) {\n      this.target.functions = _.without(this.target.functions, aliasFunc);\n      this.target.functions.push(aliasFunc);\n    }\n  }\n\n  toggleQueryOptions() {\n    this.showQueryOptions = !this.showQueryOptions;\n  }\n\n  onQueryOptionChange() {\n    this.queryOptionsText = this.renderQueryOptionsText();\n    this.onTargetBlur();\n  }\n\n  renderQueryOptionsText() {\n    var optionsMap = {\n      showDisabledItems: \"Show disabled items\",\n      skipEmptyValues: \"Skip empty values\"\n    };\n    var options = [];\n    _.forOwn(this.target.options, (value, key) => {\n      if (value) {\n        if (value === true) {\n          // Show only option name (if enabled) for boolean options\n          options.push(optionsMap[key]);\n        } else {\n          // Show \"option = value\" for another options\n          options.push(optionsMap[key] + \" = \" + value);\n        }\n      }\n    });\n    return \"Options: \" + options.join(', ');\n  }\n\n  /**\n   * Switch query editor to specified mode.\n   * Modes:\n   *  0 - items\n   *  1 - IT services\n   *  2 - Text metrics\n   */\n  switchEditorMode(mode) {\n    this.target.mode = mode;\n    this.init();\n    this.targetChanged();\n  }\n}\n","import _ from 'lodash';\nimport { migrateDSConfig } from './migrations';\n\nconst SUPPORTED_SQL_DS = ['mysql', 'postgres', 'influxdb'];\n\nconst zabbixVersions = [\n  { name: '2.x', value: 2 },\n  { name: '3.x', value: 3 },\n  { name: '4.x', value: 4 },\n];\n\nconst defaultConfig = {\n  trends: false,\n  dbConnectionEnable: false,\n  dbConnectionDatasourceId: null,\n  alerting: false,\n  addThresholds: false,\n  alertingMinSeverity: 3,\n  disableReadOnlyUsersAck: false,\n  zabbixVersion: 3,\n};\n\nexport class ZabbixDSConfigController {\n\n  /** @ngInject */\n  constructor($scope, $injector, datasourceSrv) {\n    this.datasourceSrv = datasourceSrv;\n\n    this.current.jsonData = migrateDSConfig(this.current.jsonData);\n    _.defaults(this.current.jsonData, defaultConfig);\n\n    this.dbConnectionEnable = this.current.jsonData.dbConnectionEnable;\n    this.dbConnectionDatasourceId = this.current.jsonData.dbConnectionDatasourceId;\n\n    this.dbDataSources = this.getSupportedDBDataSources();\n    this.zabbixVersions = _.cloneDeep(zabbixVersions);\n    this.autoDetectZabbixVersion();\n    if (!this.dbConnectionDatasourceId) {\n      this.loadCurrentDBDatasource();\n    }\n  }\n\n  getSupportedDBDataSources() {\n    let datasources = this.datasourceSrv.getAll();\n    return _.filter(datasources, ds => {\n      return _.includes(SUPPORTED_SQL_DS, ds.type);\n    });\n  }\n\n  getCurrentDatasourceType() {\n    const dsId = this.dbConnectionDatasourceId;\n    const currentDs = _.find(this.dbDataSources, { 'id': dsId });\n    return currentDs ? currentDs.type : null;\n  }\n\n  loadCurrentDBDatasource() {\n    const dsName= this.current.jsonData.dbConnectionDatasourceName;\n    this.datasourceSrv.loadDatasource(dsName)\n    .then(ds => {\n      if (ds) {\n        this.dbConnectionDatasourceId = ds.id;\n      }\n    });\n  }\n\n  autoDetectZabbixVersion() {\n    if (!this.current.id) {\n      return;\n    }\n\n    this.datasourceSrv.loadDatasource(this.current.name)\n    .then(ds => {\n      return ds.getVersion();\n    })\n    .then(version => {\n      if (version) {\n        if (!_.find(zabbixVersions, ['value', version])) {\n          this.zabbixVersions.push({ name: version + '.x', value: version });\n        }\n        this.current.jsonData.zabbixVersion = version;\n      }\n    });\n  }\n}\n","import _ from 'lodash';\nimport $ from 'jquery';\nimport angular from 'angular';\n\nclass ZabbixAlertingService {\n\n  /** @ngInject */\n  constructor(dashboardSrv) {\n    this.dashboardSrv = dashboardSrv;\n  }\n\n  isFullScreen() {\n    return this.dashboardSrv.dash.meta.fullscreen;\n  }\n\n  setPanelAlertState(panelId, alertState) {\n    let panelIndex;\n\n    let panelContainers = _.filter($('.panel-container'), elem => {\n      return elem.clientHeight && elem.clientWidth;\n    });\n\n    let panelModels = this.getPanelModels();\n\n    if (this.isFullScreen()) {\n      panelIndex = 0;\n    } else {\n      panelIndex = _.findIndex(panelModels, panel => {\n        return panel.id === panelId;\n      });\n    }\n\n    if (panelIndex >= 0) {\n      let alertClass = \"panel-has-alert panel-alert-state--ok panel-alert-state--alerting\";\n      $(panelContainers[panelIndex]).removeClass(alertClass);\n\n      if (alertState) {\n        if (alertState === 'alerting') {\n          alertClass = \"panel-has-alert panel-alert-state--\" + alertState;\n          $(panelContainers[panelIndex]).addClass(alertClass);\n        }\n        if (alertState === 'ok') {\n          alertClass = \"panel-alert-state--\" + alertState;\n          $(panelContainers[panelIndex]).addClass(alertClass);\n          $(panelContainers[panelIndex]).removeClass(\"panel-has-alert\");\n        }\n      }\n    }\n  }\n\n  getPanelModels() {\n    return _.filter(this.dashboardSrv.dash.panels, panel => panel.type !== 'row');\n  }\n\n  getPanelModel(panelId) {\n    let panelModels = this.getPanelModels();\n\n    return _.find(panelModels, panel => {\n      return panel.id === panelId;\n    });\n  }\n\n  setPanelThreshold(panelId, threshold) {\n    let panel = this.getPanelModel(panelId);\n    let containsThreshold = _.find(panel.thresholds, {value: threshold});\n\n    if (panel && panel.type === \"graph\" && !containsThreshold) {\n      let thresholdOptions = {\n        colorMode : \"custom\",\n        fill : false,\n        line : true,\n        lineColor: \"rgb(255, 0, 0)\",\n        op: \"gt\",\n        value: threshold,\n        source: \"zabbix\"\n      };\n\n      panel.thresholds.push(thresholdOptions);\n    }\n  }\n\n  removeZabbixThreshold(panelId) {\n    let panel = this.getPanelModel(panelId);\n\n    if (panel && panel.type === \"graph\") {\n      panel.thresholds = _.filter(panel.thresholds, threshold => {\n        return threshold.source !== \"zabbix\";\n      });\n    }\n  }\n\n}\n\nangular\n  .module('grafana.services')\n  .service('zabbixAlertingSrv', ZabbixAlertingService);\n","import angular from 'angular';\nimport _ from 'lodash';\nimport $ from 'jquery';\nimport * as metricFunctions from './metricFunctions';\n\nangular\n  .module('grafana.directives')\n  .directive('addMetricFunction',\n\n  /** @ngInject */\n  function($compile) {\n    var inputTemplate = '<input type=\"text\"'+\n                          ' class=\"gf-form-input\"' +\n                          ' spellcheck=\"false\" style=\"display:none\"></input>';\n\n    var buttonTemplate = '<a  class=\"gf-form-label tight-form-func dropdown-toggle query-part\"' +\n                            ' tabindex=\"1\" gf-dropdown=\"functionMenu\" data-toggle=\"dropdown\">' +\n                            '<i class=\"fa fa-plus\"></i></a>';\n\n    return {\n      link: function($scope, elem) {\n        var categories = metricFunctions.getCategories();\n        var allFunctions = getAllFunctionNames(categories);\n\n        $scope.functionMenu = createFunctionDropDownMenu(categories);\n\n        var $input = $(inputTemplate);\n        var $button = $(buttonTemplate);\n        $input.appendTo(elem);\n        $button.appendTo(elem);\n\n        $input.attr('data-provide', 'typeahead');\n        $input.typeahead({\n          source: allFunctions,\n          minLength: 1,\n          items: 10,\n          updater: function (value) {\n            var funcDef = metricFunctions.getFuncDef(value);\n            if (!funcDef) {\n              // try find close match\n              value = value.toLowerCase();\n              funcDef = _.find(allFunctions, function(funcName) {\n                return funcName.toLowerCase().indexOf(value) === 0;\n              });\n\n              if (!funcDef) { return; }\n            }\n\n            $scope.$apply(function() {\n              $scope.addFunction(funcDef);\n            });\n\n            $input.trigger('blur');\n            return '';\n          }\n        });\n\n        $button.click(function() {\n          $button.hide();\n          $input.show();\n          $input.focus();\n        });\n\n        $input.keyup(function() {\n          elem.toggleClass('open', $input.val() === '');\n        });\n\n        $input.blur(function() {\n          // clicking the function dropdown menu won't\n          // work if you remove class at once\n          setTimeout(function() {\n            $input.val('');\n            $input.hide();\n            $button.show();\n            elem.removeClass('open');\n          }, 200);\n        });\n\n        $compile(elem.contents())($scope);\n      }\n    };\n  });\n\nfunction getAllFunctionNames(categories) {\n  return _.reduce(categories, function(list, category) {\n    _.each(category, function(func) {\n      list.push(func.name);\n    });\n    return list;\n  }, []);\n}\n\nfunction createFunctionDropDownMenu(categories) {\n  return _.map(categories, function(list, category) {\n    return {\n      text: category,\n      submenu: _.map(list, function(value) {\n        return {\n          text: value.name,\n          click: \"ctrl.addFunction('\" + value.name + \"')\",\n        };\n      })\n    };\n  });\n}\n\n","import angular from 'angular';\nimport _ from 'lodash';\nimport $ from 'jquery';\n\nconst DOCS_FUNC_REF_URL = 'https://alexanderzobnin.github.io/grafana-zabbix/reference/functions/';\n\nangular\n  .module('grafana.directives')\n  .directive('metricFunctionEditor',\n\n  /** @ngInject */\n  function($compile, templateSrv) {\n\n    var funcSpanTemplate = '<a ng-click=\"\">{{func.def.name}}</a><span>(</span>';\n    var paramTemplate = '<input type=\"text\" style=\"display:none\"' +\n                        ' class=\"input-mini tight-form-func-param\"></input>';\n\n    var funcControlsTemplate =\n       '<div class=\"tight-form-func-controls\">' +\n         '<span class=\"pointer fa fa-arrow-left\"></span>' +\n         '<span class=\"pointer fa fa-question-circle\"></span>' +\n         '<span class=\"pointer fa fa-remove\" ></span>' +\n         '<span class=\"pointer fa fa-arrow-right\"></span>' +\n       '</div>';\n\n    return {\n      restrict: 'A',\n      link: function postLink($scope, elem) {\n        var $funcLink = $(funcSpanTemplate);\n        var $funcControls = $(funcControlsTemplate);\n        var ctrl = $scope.ctrl;\n        var func = $scope.func;\n        var funcDef = func.def;\n        var scheduledRelink = false;\n        var paramCountAtLink = 0;\n\n        function clickFuncParam(paramIndex) {\n          /*jshint validthis:true */\n\n          var $link = $(this);\n          var $input = $link.next();\n\n          $input.val(func.params[paramIndex]);\n          $input.css('width', ($link.width() + 16) + 'px');\n\n          $link.hide();\n          $input.show();\n          $input.focus();\n          $input.select();\n\n          var typeahead = $input.data('typeahead');\n          if (typeahead) {\n            $input.val('');\n            typeahead.lookup();\n          }\n        }\n\n        function scheduledRelinkIfNeeded() {\n          if (paramCountAtLink === func.params.length) {\n            return;\n          }\n\n          if (!scheduledRelink) {\n            scheduledRelink = true;\n            setTimeout(function() {\n              relink();\n              scheduledRelink = false;\n            }, 200);\n          }\n        }\n\n        function inputBlur(paramIndex) {\n          /*jshint validthis:true */\n          var $input = $(this);\n          var $link = $input.prev();\n          var newValue = $input.val();\n\n          if (newValue !== '' || func.def.params[paramIndex].optional) {\n            $link.html(templateSrv.highlightVariablesAsHtml(newValue));\n\n            func.updateParam($input.val(), paramIndex);\n            scheduledRelinkIfNeeded();\n\n            $scope.$apply(function() {\n              ctrl.targetChanged();\n            });\n\n            $input.hide();\n            $link.show();\n          }\n        }\n\n        function inputKeyPress(paramIndex, e) {\n          /*jshint validthis:true */\n          if(e.which === 13) {\n            inputBlur.call(this, paramIndex);\n          }\n        }\n\n        function inputKeyDown() {\n          /*jshint validthis:true */\n          this.style.width = (3 + this.value.length) * 8 + 'px';\n        }\n\n        function addTypeahead($input, paramIndex) {\n          $input.attr('data-provide', 'typeahead');\n\n          var options = funcDef.params[paramIndex].options;\n          if (funcDef.params[paramIndex].type === 'int' ||\n              funcDef.params[paramIndex].type === 'float') {\n            options = _.map(options, function(val) { return val.toString(); });\n          }\n\n          $input.typeahead({\n            source: options,\n            minLength: 0,\n            items: 20,\n            updater: function (value) {\n              setTimeout(function() {\n                inputBlur.call($input[0], paramIndex);\n              }, 0);\n              return value;\n            }\n          });\n\n          var typeahead = $input.data('typeahead');\n          typeahead.lookup = function () {\n            this.query = this.$element.val() || '';\n            return this.process(this.source);\n          };\n        }\n\n        function toggleFuncControls() {\n          var targetDiv = elem.closest('.tight-form');\n\n          if (elem.hasClass('show-function-controls')) {\n            elem.removeClass('show-function-controls');\n            targetDiv.removeClass('has-open-function');\n            $funcControls.hide();\n            return;\n          }\n\n          elem.addClass('show-function-controls');\n          targetDiv.addClass('has-open-function');\n\n          $funcControls.show();\n        }\n\n        function addElementsAndCompile() {\n          $funcControls.appendTo(elem);\n          $funcLink.appendTo(elem);\n\n          _.each(funcDef.params, function(param, index) {\n            if (param.optional && func.params.length <= index) {\n              return;\n            }\n\n            if (index > 0) {\n              $('<span>, </span>').appendTo(elem);\n            }\n\n            var paramValue = templateSrv.highlightVariablesAsHtml(func.params[index]);\n            var $paramLink = $('<a ng-click=\"\" class=\"graphite-func-param-link\">' + paramValue + '</a>');\n            var $input = $(paramTemplate);\n\n            paramCountAtLink++;\n\n            $paramLink.appendTo(elem);\n            $input.appendTo(elem);\n\n            $input.blur(_.partial(inputBlur, index));\n            $input.keyup(inputKeyDown);\n            $input.keypress(_.partial(inputKeyPress, index));\n            $paramLink.click(_.partial(clickFuncParam, index));\n\n            if (funcDef.params[index].options) {\n              addTypeahead($input, index);\n            }\n\n          });\n\n          $('<span>)</span>').appendTo(elem);\n\n          $compile(elem.contents())($scope);\n        }\n\n        function ifJustAddedFocusFistParam() {\n          if ($scope.func.added) {\n            $scope.func.added = false;\n            setTimeout(function() {\n              elem.find('.graphite-func-param-link').first().click();\n            }, 10);\n          }\n        }\n\n        function registerFuncControlsToggle() {\n          $funcLink.click(toggleFuncControls);\n        }\n\n        function registerFuncControlsActions() {\n          $funcControls.click(function(e) {\n            var $target = $(e.target);\n            if ($target.hasClass('fa-remove')) {\n              toggleFuncControls();\n              $scope.$apply(function() {\n                ctrl.removeFunction($scope.func);\n              });\n              return;\n            }\n\n            if ($target.hasClass('fa-arrow-left')) {\n              $scope.$apply(function() {\n                _.move($scope.target.functions, $scope.$index, $scope.$index - 1);\n                ctrl.targetChanged();\n              });\n              return;\n            }\n\n            if ($target.hasClass('fa-arrow-right')) {\n              $scope.$apply(function() {\n                _.move($scope.target.functions, $scope.$index, $scope.$index + 1);\n                ctrl.targetChanged();\n              });\n              return;\n            }\n\n            if ($target.hasClass('fa-question-circle')) {\n              var docSite = DOCS_FUNC_REF_URL;\n              window.open(docSite + '#' + funcDef.name.toLowerCase(),'_blank');\n              return;\n            }\n          });\n        }\n\n        function relink() {\n          elem.children().remove();\n\n          addElementsAndCompile();\n          ifJustAddedFocusFistParam();\n          registerFuncControlsToggle();\n          registerFuncControlsActions();\n        }\n\n        relink();\n      }\n    };\n\n  });\n"],"sourceRoot":""}